\section{Критерии сравнения моделей памяти}
\label{sec:background}

В этом разделе мы более подробно рассмотрим 
критерии сравнения моделей памяти языков программирования:
 оптимальность схем компиляции \ref{item:criteria:opt-comp},
корректность трансформаций \ref{item:criteria:sound-trans}
и предоставляемые гарантии \ref{item:criteria:reasoning}.
Эти критерии непосредственно связаны с примитивами, 
предоставляемыми абстракцией разделяемой памяти. 
Таким образом сперва нам необходимо ввести эти примитивы. 

\paragraph{Программные примитивы.}
\label{sec:background:primitives}

Модель памяти определяет семантику разделяемой памяти программы
при наличии  параллельно исполняемых потоков. 
Разделяемая память состоит из переменных, 
каждая из которых имеет уникальный адрес.% 
\footnote{В этой статье мы будем использовать 
термины "адрес" и "локация" как взаимозаменяемые.}
Потоки могут обращаться к этим переменным, 
выполняя операции чтения и записи. 

% \begin{figure}[t]
% \[\def\arraystretch{1.2}
%   \begin{array}{ll} 
%     \readInst{o}{r}{x}                  & \text{Load}                   \\ 
%     \writeInst{o}{x}{v}                 & \text{Store}                  \\ 
%     \readArrayInst{o}{r}{x}{i}{j}       & \text{Mixed Size Load}        \\ 
%     \writeArrayInst{o}{x}{v}{i}{j}      & \text{Mixed Size Store}       \\ 
%     \casInst{o}{r}{x}{v_e}{v_d}         & \text{Compare-and-Swap}       \\ 
%     \faddInst{o}{r}{x}{v}               & \text{Fetch-and-Add}          \\ 
%     \lockInst{l}                        & \text{Lock}                   \\ 
%     \unlockInst{l}                      & \text{Unlock}                 \\ 
%     \fenceInst{o}                       & \text{Fence}                  \\ 
%     x \in \mathsf{Var}                  & \text{Shared Variables}       \\ 
%     r \in \mathsf{Reg}                  & \text{Thread-Local Registers} \\ 
%     v \in \mathsf{Val}                  & \text{Values}                 \\ 
%     l \in \mathsf{Lock}                 & \text{Locks}                  \\ 
%     i,j \in \mathsf{Index}              & \text{Array Indices}          \\ 
%     o \in \set{\na,\rlx,\acqrel,\sco}   & \text{Access Modes}           \\ 
%   \end{array}
% \]
% \caption{Primitives of relaxed memory models}
% \label{fig:wmm-abs}
% \end{figure}

В большинстве языков программирования различаются 
\emph{неатомарные} (\emph{обычные})
и \emph{атомарные} переменные.
Первые не должны использоваться для  
обращений из различных параллельно исполняемых потоков программы. 
В зависимости от конкретного языка программирования
параллельные обращения к неатомарным переменным 
либо полностью запрещены системой типов
(например, в  \Haskell~\cite{Marlow-al:Haskell10, Vollmer-al:PPoPP17} и \Rust~\cite{RustBook:19}), 
либо имеют неопределенное поведение (например, в  \CPP~\cite{Boehm-Adve:PLDI08, Batty-al:POPL11}), 
либо обладают очень слабой семантикой,
не предоставляющей гарантий о порядке,
в котором  потоки могут наблюдать эти обращения
(например, в \Java~\cite{Manson-al:POPL05}). 

В свою очередь, атомарные переменные непосредственно 
предназначены для параллельных обращений. 
Некоторые модели памяти также вводят 
несколько типов обращений к атомарным переменным,  аннотируя их 
 \emph{режимом доступа} (\emph{access mode}).
Например, язык \CPP (и \Java начиная с версии 9~\cite{Bender-Palsberg:OOPSLA19})
имеет четыре следующих режима: ослабленный (\emph{relaxed}
или \emph{opaque} в терминологии \Java),
режимы захвата и освобождения (\emph{acquire/release}), 
последовательно согласованный режим (\emph{sequentially consistent}
или  \emph{volatile} в \Java). 
Эти режимы обозначаются как $\rlx$, $\acq$, $\rel$ и $\sco$ соответственно.
Заметим, что режим $\acq$ может быть применен только к операциям чтения,
а режим $\rel$ --- только к операциям записи.
Неатомарные обращения иногда рассматриваются как дополнительный режим $\na$, 
однако  одновременное использование атомарных 
и неатомарных обращений к одной и той же переменной 
влечет неопределенное поведение в программы на \CPP.

Режимы обращения упорядочены по гарантиям, 
которые они предоставляют, как показано на следующей диаграмме. 

% $$ \na \sqsubseteq \rlx \sqsubseteq \acqrel \sqsubseteq \sco $$

\input{../common/modes.tex}

На одной стороне  спектра находятся последовательно согласованные обращения.
При правильном использовании они гарантируют семантику 
последовательной согласованности
(детали этого обсуждаются в разделе \cref{sec:background:drf}).
На другой стороне  спектра находятся неатомарные обращения, которые либо не дают никаких гарантий, 
либо предоставляют минимальные гарантии. 
Ослабленные обращения также имеют слабую семантику, 
тем не менее обычно они предоставляют свойство \emph{когерентности}
(см. раздел \cref{sec:background:coh}).
Наконец, в середине спектра находятся обращения режимов захвата/освобождения. 
Они необходимы для поддержи идиомы передачи сообщений~\cite{Lahav-al:POPL16}.
Поток, которому необходимо отправить сообщение, должен выполнить операцию освобождающей записи, 
а другой поток, ожидающий это сообщение, должен выполнить операцию захватывающего чтения. 
Если операция чтения наблюдает, что  операция освобождающей записи выполнена, то два потока синхронизируются.

Модель памяти также может предоставлять атомарные операции 
\emph{чтения-модификации-записи} (\emph{read-modify-write}).
Они включают в себя операции сравнения и замены (\emph{compare-and-swap}), 
атомарного обмена (\emph{exchange}) и разные вариации атомарного инкремента, 
например, \emph{fetch-and-add}, \emph{fetch-and-sub} и т.д. 
Операция сравнения и замены принимает на вход 
адрес разделяемой переменной, а также ожидаемое и желаемое значение.
Она выполняет чтение переменной и сравнивает полученное значение 
с ожидаемым. Если они равны, то выполняется замена значения переменной 
на желаемое, а прочитанное значение возвращается как результат, 
вне зависимости от успеха проверки. 
Заметим, что описанные выше действия выполняются атомарно, 
ни одна другая операция записи не может выполнится между 
операциями чтения и записи.
Операция обмена (\emph{exchange}) атомарно 
заменит значение переменной и возвратит её прежнее значение. 
Операция атомарного инкремента (\emph{fetch-and-add} и др.)  возвращает значение переменной до модификации.  

Некоторые модели памяти рассматривают 
блокировки (\emph{locks}) как самостоятельный примитив~\cite{Manson-al:POPL05}. 
Ещё одним примитивом являются барьеры (\emph{fence})~\cite{Batty-al:POPL11},
которые соответствуют инструкциям барьеров памяти, 
выполняемых процессорами  
(см. раздел \cref{sec:background:compile}). 

Наконец, модель памяти может рассматривать разделяемую память 
не как множество независимых типизированных переменных, 
а как последовательность байт, и допускать 
так называемые \emph{смешанные} (\emph{mixed-size}) 
параллельные обращения~\cite{Flur-al:POPL17}. 
Например, в подобной модели операция чтения восьми байт по определенному адресу
может прочитать значение, записанное двумя параллельными 
операциями записи по четыре байта.

\subsection{Схема компиляции}
\label{sec:background:compile}

Будем понимать под \emph{схемой компиляции} отображение
примитивов языка программирования в инструкции 
конкретного семейства процессоров.  
Мы будем рассматривать примитивы, представленные в 
разделе \cref{sec:background:primitives}.
Архитектура процессора обычно предоставляет 
набор инструкций, который включает 
инструкции для выполнения обычных операций чтения и записи,%  
\footnote{Некоторые архитектуры
предоставляют дополнительные инструкции чтения и 
записи с режимом доступа, \eg 
\eg \texttt{lda} --- захватывающее чтение (load acquire), 
и \texttt{stl} --- освобождающая запись (store release) в \ARMv{8}.} 
операции чтения-модификации-записи, и 
также различные типы барьеров памяти.

Схема компиляции должна быть корректной. 
В контексте данной статьи мы будем подразумевать под 
этим следующее: множество сценариев поведения, допустимых
моделью памяти процессора для скомпилированной программы, 
должно являться подмножеством сценариев поведения программы, допустимых 
моделью языка программирования. 

Рассмотрим пример. 
Программа \ref{ex:sb}, представленная ниже, является 
фрагментом алгоритма Деккера, обсуждавшегося  в   \cref{sec:intro}.

\begin{equation*}
\inarrII{
   \writeInst{}{x}{1}   \\
   \readInst{}{r_1}{y}  \\
}{
  \writeInst{}{y}{1}   \\
  \readInst{}{r_2}{x}  \\
}
\tag{SB}\label{ex:sb}
\end{equation*}

Предположим, что язык программирования предоставляет 
модель последовательной согласованности, а программа
должна быть скомпилирована для процессора \Intel. 
Если компилировать операции чтения и записи 
как обычные инструкции чтения и записи \Intel \footnote{
В архитектуре \Intel инструкция \texttt{MOV} 
используется как для чтения, так и для записи в память.},
тогда результат работы скомпилированной программы
${[r_1=0, r_2=0]}$ будет допустим спецификацией модели памяти~\Intel
и может наблюдаться на практике. 
Данный результат может появиться вследствие 
\emph{буферизации операций записи}
(отсюда и название программы \ref{ex:sb} --- \emph{store buffering}) ---  
операция записи ${\writeInst{}{x}{1}}$ может быть буферизована 
и исполнена после выполнения всех остальных инструкций программы. 

Отметим, что результат ${[r_1=0, r_2=0]}$ не является результатом последовательно согласованного сценария,
и, следовательно, рассмотренная схема компиляции не является корректной. 
Как было продемонстрировано в разделе \cref{sec:intro}, 
некорректность схемы компиляции может иметь 
негативные последствия и нарушать корректность программы. 

Корректная схема компиляции для модели последовательной согласованности 
под архитектуру \Intel может компилировать 
операцию записи как обычную инструкцию записи, за которой следует 
инструкция \texttt{mfence}~\cite{Sewell-al:CACM10, Batty-al:POPL11}, 
как продемонстрировано ниже:

\begin{equation*}
\inarrII{
   \writeInst{}{x}{1}   \\
   \mfenceInst          \\
   \readInst{}{r_1}{y}  \\
}{
  \writeInst{}{y}{1}   \\
  \mfenceInst          \\
  \readInst{}{r_2}{x}  \\
}
\tag{SB+MFENCE}\label{ex:sb-mfence}
\end{equation*}

Инструкция \texttt{mfence} --- это специальный барьер памяти в системе команд процессоров 
\Intel, которая выполняет сброс буфера записей в основную память. 
Для программы \ref{ex:sb-mfence} результат ${[r_1=0, r_2=0]}$
запрещен моделью памяти \Intel. 

Несмотря на то, что модифицированная схема компиляции является корректной, 
она не \emph{оптимальна}~\cite{OptimalCompilationCPP}
в том смысле, что она использует барьеры памяти,
которые обычно являются причиной замедления программы 
на 10-30\%~\cite{Marino-al:PLDI11, Liu-al:OOPSLA17}
(\emph{см.} \cref{sec:catalog:sc}).
К сожалению, невозможно иметь одновременно \emph{корректную и оптимальную} 
схему компиляции модели последовательной согласованности 
для современных процессоров. 
Этот факт делает модель \SC неподходящей 
для высокопроизводительных языков программирования 
и служит одним из стимулов ослабления моделей памяти. 

В рамках этой статьи при обсуждении 
схем компиляции мы будем рассматривать процессоры семейств
\Intel, \ARMv{7}, \ARMv{8} и \POWER 
по двум основным причинам. 
Во-первых, эти архитектуры наиболее 
распространены на сегодняшний день. 
Во-вторых, модели памяти для этих процессоров 
всесторонне изучались исследовательским сообществом, 
что привело к созданию строгих 
формальных спецификаций~% 
\cite{Sewell-al:CACM10, Sarkar-al:PLDI11, 
Flur-al:POPL16, Pulte-al:POPL18}. 

\subsection{Трансформации кода}
\label{sec:background:trans}

Следующим критерием является ~\ref{item:criteria:sound-trans} ---
корректность трансформаций, то есть правил переписывания 
исходного кода, применяемых в компиляторных оптимизациях. 

\emph{Корректная} трансформация должна сохранять семантику программы. 
В нашем контексте, как и в случае корректности схемы компиляции,
это означает, что множество допустимых сценариев поведения 
программы после применения трансформации должно 
быть подмножеством допустимых сценариев поведения оригинальной программы.

Возвращаясь к примеру \ref{ex:sb},
снова вернемся к модели последовательной согласованности 
и рассмотрим трансформацию, которая переставляет местами 
операцию записи и операцию чтения в левом потоке предполагая, 
что они оперируют различными локациями в памяти:

\begin{minipage}{0.45\linewidth}
\begin{equation*}
\inarrII{
   \writeInst{}{x}{1}   \\
   \readInst{}{r_1}{y}  \\
}{
  \writeInst{}{y}{1}   \\
  \readInst{}{r_2}{x}  \\
}
% \tag{SB}\label{ex:sb-src}
\end{equation*}
\end{minipage}\hfill%
\begin{minipage}{0.05\linewidth}
\Large~\\ $\leadsto$
\end{minipage}\hfill%
\begin{minipage}{0.45\linewidth}
\begin{equation*}
\inarrII{
   \readInst{}{r_1}{y}  \\
   \writeInst{}{x}{1}   \\
}{
  \writeInst{}{y}{1}   \\
  \readInst{}{r_2}{x}  \\
}
% \tag{SBtr}\label{ex:sb-tgt}
\end{equation*}
\end{minipage}

Для преобразованной версии программы (справа),
результат $[r_1=0, r_2=0]$ является последовательно согласованным. 
Тем не менее, для оригинальной версии программы (слева) это неверно. 
Следовательно, вышеупомянутая трансформация 
является некорректной для модели \SC. 

В следующих разделах мы рассмотрим  некоторые  трансформации,
обсуждаемые в различных исследованиях, 
с краткими пояснениям каждой трансформации. 
Заметим, что этот список далеко не полон 
и не включает многие оптимизации, 
выполняемые существующими компиляторами~\cite{Muchnick:ACDI97}.
Например, он не включает оптимизации над циклами,
так как в теории моделей памяти ещё недостаточно 
проработаны темы гарантий прогресса 
(\emph{liveness properties})~\cite{Lahav-al:arXiv20}, 
которые необходимы для формального 
изучения этих трансформаций. 

Трансформации, которые мы рассматриваем,  
разделены на два подкласса: \emph{локальные} и \emph{глобальные}.
Локальные трансформации выполняют переписывание 
небольшого участка кода в пределах одного потока. 
Для выполнения глобальных трансформаций 
необходимо рассматривать всю программу 
или её большую часть, 
захватывая несколько потоков.      
 
\subsubsection{Локальные трансформации}

\paragraph{
Переупорядочивание независимых инструкций
(Reordering of Independent Instructions).
} 

Эта трансформация выполняет перестановку 
двух смежных инструкций, выполняющих обращение к 
различным адресам памяти. 
В зависимости от конкретной пары обращений выделяют 
четыре типа переупорядочивания:
запись/чтение, запись/запись,
чтение/чтение и чтение/запись. 
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{cccl} 

      \writeInst{}{x}{v} \seq \readInst{}{r}{y} 
    & \leadsto 
    & \readInst{}{r}{y} \seq \writeInst{}{x}{v}
    & \text{store/load}  \\ 

      \writeInst{}{x}{v} \seq \writeInst{}{y}{u} 
    & \leadsto 
    & \writeInst{}{y}{u} \seq \writeInst{}{x}{v}
    & \text{store/store}  \\ 

      \readInst{}{r}{x} \seq \readInst{}{s}{y} 
    & \leadsto 
    & \readInst{}{s}{y} \seq \readInst{}{r}{x}
    & \text{load/load}  \\ 

      \readInst{}{r}{x} \seq \writeInst{}{y}{v} 
    & \leadsto 
    & \writeInst{}{y}{v} \seq \readInst{}{r}{x}
    & \text{load/store}  \\ 

  \end{array}
\]

\paragraph{
Элиминация избыточного обращения
(Elimination of Redundant Access).
} 

В паре двух смежных обращений к памяти
одно из них может быть удалено, 
если его эффект покрывается другим. 
Например, две операции записи в одну и ту же переменную 
одного и того же значения могут быть заменены 
на одну операцию записи. 
Аналогично переупорядочиванию инструкций, 
выделяют четыре класса трансформация этого вида. 
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{cccl} 

      \writeInst{}{x}{v} \seq \readInst{}{r}{x} 
    & \leadsto 
    & \writeInst{}{x}{v} \seq \assignInst{r}{v}
    & \text{store/load}  \\ 

      \readInst{}{r}{x} \seq \readInst{}{s}{x} 
    & \leadsto 
    & \readInst{}{r}{x} \seq \assignInst{s}{r}
    & \text{load/load}  \\ 

      \readInst{}{r}{x} \seq \writeInst{}{x}{r} 
    & \leadsto 
    & \readInst{}{r}{x} 
    & \text{load/store}  \\ 

      \writeInst{}{x}{v} \seq \writeInst{}{x}{u} 
    & \leadsto 
    & \writeInst{}{x}{u}
    & \text{store/store}  \\ 

  \end{array}
\]

\paragraph{
Элиминация нерелевантной операции чтения
(Irrelevant Load Elimination).
}

Эта трансформация удаляет инструкцию чтения, 
если её результат не используется в программе. 
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{cccl} 

      \readInst{}{r}{x} 
    & \leadsto 
    & \epsInst
    & ~|~ \text{$r$ is never used}  \\ 

  \end{array}
\]

\paragraph{
Введение спекулятивной операции чтения
(Speculative Load Introduction).
}

Эта трансформация является обратной к предыдущей и вставляет инструкцию чтения в произвольное место программы.
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{cccl} 

      \epsInst
    & \leadsto 
    & \readInst{}{r}{x} 
    & ~|~ \text{$r$ is never used}  \\ 

  \end{array}
\]

В комбинации с элиминацей типа чтение/чтение 
эта трансформация может быть использована 
для того, чтобы вынести чтение из 
ветки условного оператора:
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{ccc} 

      \kw{if} (e)~ \kw{then} \{ \readInst{}{r}{x} \}
    & \leadsto 
    & \readInst{}{s}{x} \seq \kw{if} (e)~ \kw{then} \{ \assignInst{r}{s} \} \\
    & & ~|~ \text{$s$ is never used}  \\ 

  \end{array}
\]

\paragraph{
(Roach Motel Reordering).
}

Этот класс трансформаций позволяет вносить инструкции в блоки синхронизации. 
Например, инструкция записи может быть 
перенесена в критическую секции, то есть
переставлена за последующую операцию захвата блокировки. 
Интуитивно, такие перестановки могут 
только увеличить степень синхронизацию в программе, 
то есть преобразованная программа 
должна обладать меньшим недетерминизмом 
и иметь меньшее количество допустимых сценариев поведения. 

Неатомарные обращения могут быть внесены 
в критическую секцию без дополнительных предусловий. 
Кроме того, инструкция записи может быть перемещена после 
операции захвата блокировки, а инструкция чтения 
может быть перемещена до операции освобождения блокировки. 
Схожие правила применяются к перестановке операций вокруг 
захватывающих (\emph{acquire}) и освобождающих (\emph{release}) 
обращений к памяти. 
% %
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{cccl} 

      \readInst{\na}{r}{x} \seq \lockInst{l} 
    & \leadsto 
    & \lockInst{l} \seq \readInst{\na}{r}{x}
    & ~ \\ 

      \writeInst{o}{x}{v} \seq \lockInst{l} 
    & \leadsto 
    & \lockInst{l} \seq \writeInst{o}{x}{v}
    & ~  \\ 

      \unlockInst{l} \seq \writeInst{\na}{x}{v} 
    & \leadsto 
    & \writeInst{\na}{x}{v} \seq \unlockInst{l}
    & ~ \\ 


      \unlockInst{l} \seq \readInst{o}{r}{x} 
    & \leadsto 
    & \readInst{o}{r}{x} \seq \unlockInst{l}
    & ~  \\ 

  \end{array}
\]


\paragraph{
Усиление обращений
(Strengthening).
}

Подобно предыдущей, данная трансформация 
увеличивает степень синхронизации в программе 
путем усиления режима обращения к переменной.
Например, неатомарное обращение к переменной  может быть заменено на 
последовательно согласованное: 
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{cccl} 

      \readInst{o}{r}{x} 
    & \leadsto 
    & \readInst{o'}{r}{x}
    & ~|~ o \sqsubset o' \\ 

      \writeInst{o}{x}{v}
    & \leadsto 
    & \writeInst{o'}{x}{v}
    & ~|~ o \sqsubset o'  \\ 

  \end{array}
\]

\paragraph{
Трансформации, сохраняющие трассы
(Trace Preserving Transformations).
}

Этот широкий класс трансформаций, который включает трансформации, 
не меняющие множество трасс потока~\cite{Sevcik-Aspinall:ECOOP08}.
Трассой называется последовательность видимых побочных эффектов,
производимых во время исполнения потока 
(операции чтения и записи в разделяемую память тоже считаются эффектами).
Классический пример подобной трансформации --- это \emph{распространение констант}%
~\cite{Muchnick:ACDI97, Wegman-Zadeck:TOPLAS91}.
Ниже приведен пример применения данной трансформации: 
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{cccl} 

      \writeInst{}{x}{0 + v} 
    & \leadsto 
    & \writeInst{}{x}{v}
    & \\ 

  \end{array}
\]
  
\paragraph{
Удаление общих подвыражений
(Common Subexpression Elimination).
}

\CSE является ещё одной классической трансформацией~\cite{Muchnick:ACDI97}, 
которая выполняет поиск и удаление идентичных подвыражений.
Вот пример выполнения этой трансформации:
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{cccl} 

      \readInst{}{r_1}{x + y} \seq \readInst{}{r_2}{x + y} 
    & \leadsto 
    & \readInst{}{r_1}{x + y} \seq \readInst{}{r_2}{r_1}
    & \\ 

  \end{array}
\]

\subsubsection{Глобальные трансформации}

\paragraph{
Продвижение регистров
(Register Promotion).
}

Если компилятор может определить, что 
обращения к разделяемой переменной 
происходят только из одного потока,
тогда он может заменить эту переменную на регистр.
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{ccl} 

      \writeInst{}{x}{v} \seq \readInst{}{r}{x} 
    & \leadsto 
    & \assignInst{s}{v} \seq \assignInst{r}{s}
    \\ 
    
    & & |~ \text{\texttt{x} is not accessed from other threads} \\
    & & |~ \text{\texttt{s} is a fresh register} \\ 

  \end{array}
\]

\paragraph{Слияние потоков (Thread Inlining).}

Эта трансформация объединяет два потока в один.
Оказывается, что эта на первый взгляд простая и очевидная
трансформация не является корректной во многих моделях памяти. 
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{cccl} 

      P \pll Q 
    & \leadsto 
    & P ~\seq Q
    & ~ \\ 
    
  \end{array}
\]


\paragraph{
Трансформации, основанные на анализе диапазона значений
(Value Range Based Transformations).
}

Трансформации этого класса могут быть применены в случае,
если программа удовлетворяет некоторому инварианту,
выведенному с помощью глобального анализа 
диапазона возможных значений переменной.
Например, в программе ниже условный оператор
может быть удален, так как статический 
анализ может вывести инвариант 
$\mathsf{x} \geq \mathsf{0}$.

{\footnotesize
\begin{minipage}{0.45\linewidth}
\begin{equation*}
\inarrII{
   \readInst{}{r_1}{x}             \\
   \kw{if} (r_1 \geq 0) ~\kw{then} \\
   \quad\writeInst{}{y}{1}         \\
}{
  \readInst{}{r_2}{x}               \\
  \writeInst{}{y}{r_2}              \\
}
\end{equation*}
\end{minipage}\hfill%
\begin{minipage}{0.05\linewidth}
\Large~\\ $\leadsto$
\end{minipage}\hfill%
\begin{minipage}{0.4\linewidth}
\begin{equation*}
\inarrII{
   \readInst{}{r_1}{x}             \\
   \writeInst{}{y}{1}              \\
}{
  \readInst{}{r_2}{x}               \\
  \writeInst{}{y}{r_2}              \\
}
\end{equation*}
\end{minipage}
}

\subsection{Гарантии}

Далее мы обсуждаем третий критерий~\ref{item:criteria:reasoning} ---
гарантии о поведении программ, предоставляемые моделью памяти.

\subsubsection{\DRF-свойство}
\label{sec:background:drf}

При рассуждении о многопоточных программах  
большинство программистов подразумевают 
модель последовательной согласованности. 
Действительно, было бы неправильно ожидать
от программистов знания всех деталей слабых моделей, 
так как это только усложнило бы и без того 
непростую задачу проектирования и разработки
многопоточных программ. 
Для того чтобы решить эту проблему, 
было предложено свойство \emph{свободы от гонок}
(\emph{data-race freedom}, \DRF)~\cite{Manson-al:POPL05}.
Это свойство гарантирует, что при наличии 
достаточной синхронизации программа будет иметь 
только последовательно согласованные сценарии поведения в слабой модели памяти. 
Другими словами, если слабая модель памяти обладает \DRF-свойством, 
то при условии правильного использования примитивов синхронизации
программист может не задумываться о слабых сценариях поведения 
и подразумевать модель последовательной согласованности.

Рассмотрим пример. 
Вернемся к программе \ref{ex:sb} из \cref{sec:background:compile}.
Как было продемонстрировано ранее, в слабой модели 
эта программа может допускать результат ${[r_1=0, r_2=0]}$.
Тем не менее, семантика последовательной согласованности
может быть восстановлена, например, при помощи блокировок, 
как показано в примере ниже:

\begin{equation*}
\inarrII{
   \lockInst{l}         \\
   \writeInst{}{x}{1}   \\
   \readInst{}{r_1}{y}  \\
   \unlockInst{l}       \\
}{
   \lockInst{l}         \\
   \writeInst{}{y}{1}   \\
   \readInst{}{r_2}{x}  \\
   \unlockInst{l}       \\
}
\tag{SB+LOCK}\label{ex:sb-lock}
\end{equation*}

Совместимая с \DRF-свойством слабая модель памяти должна гарантировать, 
что для программы выше допустимы только 
последовательно согласованные сценарии поведения с результатами
${[r_1=0, r_2=1]}$, ${[r_1=1,r_2=0]}$ или ${[r_1=1,r_2=1]}$.

Если модель предоставляет последовательно согласованный 
режим доступа, тогда программист также может 
аннотировать все обращения к переменным как последовательно согласованные
и таким образом восстановить семантику \SC:
 
\begin{equation*}
\inarrII{
   \writeInst{\sco}{x}{1}   \\
   \readInst{\sco}{r_1}{y}  \\
}{
   \writeInst{\sco}{y}{1}   \\
   \readInst{\sco}{r_2}{x}  \\
}
\tag{SB+SC}\label{ex:sb-sc}
\end{equation*}

Более формально, \DRF-свойство для слабой модели $M$
утверждает, что если программа не содержит гонок в модели 
последовательной согласованности, тогда модель $M$
допускает только последовательно согласованные 
сценарии поведения для этой программы.

Итак, свойство \DRF позволяет свести рассуждения о поведении программы 
в слабой модели к рассуждениям в модели последовательной согласованности.
Достаточно лишь показать, что программа не имеет гонок 
в модели \SC, чтобы иметь факт, что она будет иметь только \SC 
сценарии поведения в слабой модели. 

Свойство \DRF в приведенной  выше формулировке иногда также называется
\emph{внешней свободой от гонок} (\eDRF), 
чтобы отличать его от \emph{внутренней свободы от гонок} (\iDRF).
\iDRF-свойство гарантирует для программы семантику \SC
в слабой модели $M$ только в случае, если программа 
не имеет гонок в \textbf{самой модели $M$}.
Это свойство предоставляет более слабую гарантию
по сравнению с внешней свободой от гонок. 
Оно не позволяет полностью избежать рассуждений 
в терминах слабой модели, так как 
сначала необходимо показать, что программа не имеет гонок именно в слабой модели. 
Как будет продемонстрировано далее (\emph{см.} \cref{sec:analysis:oota}), 
внутренняя свобода от гонок является компромиссом 
для определенного класса моделей, которые не могут 
предоставить внешнюю свободу от гонок. 

\subsubsection{Когерентность}
\label{sec:background:coh}

Как было показано раньше, современные процессоры
не гарантируют выполнимость модели последовательной согласованности. 
Тем не менее, обычно они предоставляют более слабую 
гарантию \emph{последовательной согласованности 
по каждой локации в памяти}, именуемую также 
\emph{когерентностью}~\cite{Alglave-al:TOPLAS14}. 
Соответственно, модели памяти 
для языков программирования также зачастую предоставляют эту гарантию.

Когерентность гарантирует, что все операции записи 
по определенному адресу памяти будут полностью упорядочены,
и что получающийся в результате \emph{порядок когерентности} 
(\emph{coherence order}) отражает порядок, 
в котором эффекты от операций записи, выполненных некоторым потоком, 
достигают основной памяти и становятся видимыми для других потоков.
В частности, из свойства когерентности следует, 
что программа, состоящая из обращений только 
к одной локации в памяти, должна 
обладать семантикой последовательной согласованности.
Например, рассмотрим следующую программу:

\begin{equation*}
\inarrII{
   \writeInst{}{x}{1}   \\
   \readInst{}{r_1}{x}  \\
}{
   \writeInst{}{x}{2}   \\
   \readInst{}{r_2}{x}  \\
}
\tag{COH}\label{ex:coh}
\end{equation*}

Наличие свойства когерентности предписывает модели памяти 
присвоить этой программе только последовательно 
согласованные сценарии поведения с результатами
${[r_1=1, r_2=2]}$, ${[r_1=1, r_2=1]}$ или ${[r_1=2, r_2=2]}$.
Для модели, не удовлетворяющей свойству когерентности, 
допустимым также является результат ${[r_1=2, r_2=1]}$.
Например, модель памяти \Java допускает подобный сценарий поведения~\cite{Manson-al:POPL05}.

\subsubsection{Неопределенное поведение}
\label{sec:background:ub}

Как мы уже кратко упоминали, некоторые модели памяти, например, \CPP, рассматривают программы с гонками 
на неатомарных обращениях как имеющие 
\emph{неопределенное поведение}~\cite{Boehm-Adve:PLDI08}.
Другими словами, для таких программ любое поведение считается допустимым. 
Это свойство также иногда называется 
\emph{возгорающейся семантикой} (\emph{catch-fire semantics}).
 
Практическая польза такого подхода заключается в том,
что он допускает оптимальную схему компиляции для 
неатомарных обращений и позволяет применять к ним 
любые оптимизации, корректные для последовательных программ.
Дело в том, что эффекты от оптимизаций, осуществляемых процессором или компилятором, могут наблюдаться только при обращениях к переменным из параллельных потоков. 
Если таким обращениям предписывается неопределенное поведение и на них 
не распространяются никакие гарантии, то тогда эффекты этих оптимизаций 
становятся неразличимы с точки зрения семантики программы. 
 
\subsubsection{Спекулятивное исполнение и значения из воздуха}
\label{sec:background:oota}

Чтобы представить последние два свойства, 
а именно наличие спекулятивного исполнения и значений из воздуха, 
мы рассмотрим ещё один пример:

\begin{equation*}
\inarrII{
  \readInst{}{r_1}{x}     \\
  \writeInst{}{y}{1}      \\
}{
  \readInst{}{r_2}{y}     \\
  \writeInst{}{x}{r_2}    \\
}
\tag{LB}\label{ex:lb}
\end{equation*}

Предположим, что модель памяти допускает 
результат ${[r_1=1, r_2=1]}$ для этой программы. 
Например, модели семейств процессоров 
\ARMv{7}, \ARMv{8} и \POWER
допускают  сценарий поведения, ведущий к такому результату, 
и этот сценарий может наблюдаться на некоторых процессорах семейства 
\ARMv{7}~\cite{Maranget-al:Tutorial2012}.

Результат ${[r_1=1, r_2=1]}$ не может быть получен 
путем исполнения инструкции согласно их порядку внутри потоков.
Чтобы получить подобное поведение, 
модель памяти должна  использовать 
некоторую форму \emph{спекулятивного исполнения}~\cite{Boudol-Petri:ESOP10, Boehm-Demsky:MSPC14}.
Это означает, что  операция чтения $\readInst{}{r_1}{x}$
должна быть буферизована, а операция записи $\writeInst{}{y}{1}$ 
должна выполнится вне очереди 
(отсюда и название программы выше --- 
буферизация операции чтения \emph{load buffering}).

Однако неограниченные спекуляции могут привести 
к нежелательным последствиям. 
Операция записи, исполненная вне очереди, может обернуться
самоисполняющемся пророчеством~\cite{Boehm-Demsky:MSPC14}. 
Рассмотрим следующий вариант программы с буферизацией операции чтения:

\begin{equation*}
\small
\inarrII{
  \readInst{}{r_1}{x}   \\
  \writeInst{}{y}{r_1}  \\
}{
  \readInst{}{r_2}{y}   \\
  \writeInst{}{x}{r_2}  \\
}
\tag{LB+data}\label{ex:lb+data}
\end{equation*}

Здесь гипотетическая абстрактная машина 
может спекулятивно исполнить операцию записи в переменную \texttt{y}
значения \texttt{1} в левом потоке, 
затем прочитать это значение в правом потоке, 
записать его в переменную \texttt{x} и прочитать обратно из 
первого потока, таким образом сформировав парадоксальный цикл 
причинно-следственных связей.  
Значение \texttt{1} в примере выше появляется \emph{из воздуха}
(\emph{out of thin-air}) и приводит 
к неожиданному результату ${[r_1=1, r_2=1]}$.

Как будет показано в \cref{sec:analysis},
возможность спекулятивного исполнения необходима для того, чтобы 
поддержать в модели памяти некоторый класс трансформаций программ. 
Тем не менее, спекулятивное исполнения необходимо 
ограничить должным образом, чтобы избежать 
появления значений из воздуха. 
В \cref{sec:analysis:porf,sec:analysis:deprf,sec:analysis:sdeprf}
мы рассмотрим то, как эта проблема решается в различных моделях памяти. 
