\section{Критерии сравнения моделей памяти}
\label{sec:background}

В этом разделе мы более подробно рассмотрим 
выбранные критерии сравнения моделей памяти языков программирования ---
 оптимальность схем компиляции \ref{item:criteria:opt-comp},
корректность трансформаций \ref{item:criteria:sound-trans}
и предоставляемые гарантии \ref{item:criteria:reasoning}.
Эти критерии непосредственно связаны с примитивами, 
предоставляемыми абстракцией разделяемой памяти. 
Таким образом в начале нам необходимо рассмотерть эти примитивы. 

\paragraph{Программные примитивы.}
\label{sec:background:primitives}

Модель памяти определяет семантику разделяемой памяти программы
при наличии  параллельно исполняемых потоков. 
Разделяемая память состоит из переменных, 
каждая из которых имеет уникальный адрес.% 
\footnote{В этой статье мы будем использовать 
термины "адрес" и "локация" как взаимозаменяемые.}
Потоки могут обращаться к этим переменным, 
выполняя операции чтения и записи. 


В большинстве языков программирования различатся следующие виды переменных:
\emph{неатомарные} (\emph{non-atomic}),
также именуемые как \emph{обычные} (\emph{plain}),
и \emph{атомарные} (\emph{atomic}).
Первые не должны использоваться для  
обращений из различных параллельно исполняемых потоков программы. 
В зависимости от конкретного языка 
параллельные обращения к неатомарным переменным 
либо полностью запрещены 
(например, в  \Haskell~\cite{Marlow-al:Haskell10, Vollmer-al:PPoPP17} и \Rust~\cite{RustBook:19}), 
либо имеют неопределенное поведение (например, в  \CPP~\cite{Boehm-Adve:PLDI08, Batty-al:POPL11}), 
либо обладают очень слабой семантикой,
не предоставляющей гарантий о порядке,
в котором  потоки могут наблюдать эти обращения
(например, в \Java~\cite{Manson-al:POPL05}). 

В свою очередь, атомарные переменные как раз 
предназначены для параллельных обращений. 
Некоторые модели памяти вводят 
несколько типов обращений к атомарным переменным, аннотируя их 
 \emph{режимом доступа} (\emph{access mode}).
Например, языки \CPP и \Java (начиная с версии 9~\cite{Bender-Palsberg:OOPSLA19})
имеют следующие режима доступа: ослабленный режим
(\emph{relaxed} или \emph{opaque} в терминологии \Java),
режимы захвата и освобождения (\emph{acquire/release}), 
последовательно согласованный режим (\emph{sequentially consistent}
или  \emph{volatile} в \Java). 
Эти режимы обозначаются как $\rlx$, $\acq$, $\rel$ и $\sco$ соответственно.
Заметим, что режим $\acq$ может быть применен только к операциям чтения,
а режим $\rel$ --- только к операциям записи.
Неатомарные обращения иногда рассматриваются как дополнительный режим $\na$. 
% однако  одновременное использование атомарных 
% и неатомарных обращений к одной и той же переменной 
% приводит к неопределенному поведению в программах на языке \CPP.

Режимы обращения упорядочены по гарантиям, 
которые они предоставляют, как показано на следующей диаграмме. 

\input{../common/modes.tex}

На одном конце спектра находятся последовательно согласованные обращения.
При правильном использовании они гарантируют семантику 
последовательной согласованности
(детали этого обсуждаются в разделе \cref{sec:background:drf}).
На другом конце  спектра находятся неатомарные обращения, которые либо не дают никаких гарантий, 
либо предоставляют минимальные гарантии. 
Ослабленные обращения также имеют слабую семантику, 
тем не менее обычно они предоставляют свойство \emph{когерентности}
(см. раздел \cref{sec:background:coh}).
Наконец, в середине спектра находятся обращения, имеющие режимы захвата/освобождения. 
Они используются для поддержки идиомы передачи сообщений~\cite{Lahav-al:POPL16}.
Поток, которому необходимо отправить сообщение, должен выполнить операцию освобождающей записи, 
а другой поток, ожидающий это сообщение, должен выполнить операцию захватывающего чтения. 
Если операция чтения наблюдает, что  операция освобождающей записи выполнена, то два потока синхронизируются.

Модель памяти также может предоставлять атомарные операции 
\emph{чтения-модификации-записи} (\emph{read-modify-write}).
Они включают в себя операции сравнения и замены (\emph{compare-and-swap}), 
атомарного обмена (\emph{exchange}) и разные вариации атомарного инкремента, 
например, \emph{fetch-and-add}, \emph{fetch-and-sub} и т.д. 
Операция сравнения и замены принимает на вход 
адрес разделяемой переменной, а также ожидаемое и желаемое значение.
Она выполняет чтение переменной и сравнивает полученное значение 
с ожидаемым. Если они равны, то выполняется замена значения переменной 
на желаемое, а прочитанное значение возвращается как результат, 
вне зависимости от успеха проверки. 
Заметим, что описанные выше действия выполняются атомарно, т.е.
ни одна другая операция записи не может выполнится между 
операциями чтения и записи.
Операция обмена (\emph{exchange}) атомарно 
заменит значение переменной и возвратит её прежнее значение. 
Операция атомарного инкремента (\emph{fetch-and-add} и др.) 
инкрементирует значение переменной и
возвращает её значение  до модификации.  

Некоторые модели памяти рассматривают 
блокировки (\emph{locks}) как самостоятельный примитив~\cite{Manson-al:POPL05}. 
Ещё одним примитивом являются барьеры (\emph{fence})~\cite{Batty-al:POPL11},
которые соответствуют инструкциям барьеров памяти, 
выполняемых процессорами  
(см. раздел \cref{sec:background:compile}). 

Наконец, модель может рассматривать разделяемую память 
не как множество независимых типизированных переменных, 
а как последовательность байт, и допускать 
так называемые \emph{смешанные} (\emph{mixed-size}) 
параллельные обращения~\cite{Flur-al:POPL17}. 
Например, в подобной модели операция чтения восьми байт по определенному адресу
может прочитать значение, записанное двумя параллельными 
операциями записи по четыре байта.

\subsection{Схема компиляции}
\label{sec:background:compile}

Будем понимать под \emph{схемой компиляции} отображение
примитивов языка программирования в инструкции 
конкретного семейства процессоров.  
Мы будем рассматривать примитивы, представленные в 
разделе \cref{sec:background:primitives}.
Процессоры обычно предоставляют 
инструкции для выполнения обычных операций чтения и записи%  
\footnote{Некоторые архитектуры
предоставляют дополнительные инструкции чтения и 
записи с определённым режим доступа, например,  \ARMv{8} \texttt{lda} --- захватывающее чтение (load acquire), 
\texttt{stl} --- освобождающая запись (store release).}, 
операции чтения-модификации-записи, а 
также различные типы барьеров памяти.

Схема компиляции должна быть корректной, т.е
обеспечивать, что множество сценариев поведения, допустимых 
моделью памяти процессора для скомпилированной программы, будет 
являться подмножеством сценариев поведения программы, допустимых 
моделью языка программирования. 

Рассмотрим пример. 
Программа \ref{ex:sb}, представленная ниже, является 
фрагментом алгоритма Деккера, обсуждавшегося  в \cref{sec:intro}.

\begin{equation*}
\inarrII{
   \writeInst{}{x}{1}   \\
   \readInst{}{r_1}{y}  \\
}{
  \writeInst{}{y}{1}   \\
  \readInst{}{r_2}{x}  \\
}
\tag{SB}\label{ex:sb}
\end{equation*}


Предположим, что язык программирования предоставляет 
модель последовательной согласованности, а программа
должна быть скомпилирована для \Intel. 
Если компилировать операции чтения и записи 
обычным образом \Intel \footnote{
В архитектуре \Intel инструкция \texttt{MOV} 
используется для чтения и записи в память.},
тогда, следуя спецификации модели памяти~\Intel, допустимым будет следующий результат работы программы (он также будет наблюдаться и на практике):
${[r_1=0, r_2=0]}$. 
Данный результат может появиться вследствие 
\emph{буферизации операций записи} --- 
операция записи ${\writeInst{}{x}{1}}$ может быть исполнена после выполнения всех остальных инструкций программы.


Отметим, что результат ${[r_1=0, r_2=0]}$ не является результатом последовательно согласованного сценария,
и, следовательно, рассмотренная схема компиляции не является корректной. 
Как было продемонстрировано в разделе \cref{sec:intro}, 
некорректность схемы компиляции может иметь 
негативные последствия и нарушать корректность программы. 

Корректная схема компиляции для модели последовательной согласованности 
под архитектуру \Intel может компилировать 
операцию записи как обычную инструкцию записи, за которой следует 
инструкция \texttt{mfence}~\cite{Sewell-al:CACM10, Batty-al:POPL11}, 
как продемонстрировано ниже:

\begin{equation*}
\inarrII{
   \writeInst{}{x}{1}   \\
   \mfenceInst          \\
   \readInst{}{r_1}{y}  \\
}{
  \writeInst{}{y}{1}   \\
  \mfenceInst          \\
  \readInst{}{r_2}{x}  \\
}
\tag{SB+MFENCE}\label{ex:sb-mfence}
\end{equation*}

Инструкция \texttt{mfence} является специальным барьером памяти в системе команд процессоров 
\Intel, который выполняет сброс буфера записей в основную память. 
Для программы \ref{ex:sb-mfence} результат ${[r_1=0, r_2=0]}$
запрещен моделью памяти \Intel. 

Несмотря на то, что модифицированная схема компиляции является корректной, 
она не \emph{оптимальна}~\cite{OptimalCompilationCPP}
в том смысле, что она использует барьеры памяти,
которые обычно являются причиной замедления программы 
на 10-30\% на процессорах семейства \Intel~\cite{Marino-al:PLDI11, Liu-al:OOPSLA17}.
%(\emph{см.} \cref{sec:catalog:sc}).
К сожалению, невозможно иметь одновременно \emph{корректную и оптимальную} 
схему компиляции модели последовательной согласованности 
для современных процессоров. 
Этот факт делает модель \SC неподходящей 
для высокопроизводительных языков программирования 
и служит одним из стимулов к ослаблению моделей памяти. 

В рамках этой статьи при обсуждении 
схем компиляции мы будем рассматривать процессоры семейств
\Intel, \ARMv{7}, \ARMv{8} и \POWER 
по следующим причинам. 
Во-первых, эти архитектуры наиболее 
распространены на сегодняшний день. 
Во-вторых, модели памяти для этих процессоров 
всесторонне изучены  исследовательским сообществом, 
что привело к созданию строгих 
формальных спецификаций~% 
\cite{Sewell-al:CACM10, Sarkar-al:PLDI11, 
Flur-al:POPL16, Pulte-al:POPL18}. 

\subsection{Трансформации кода}
\label{sec:background:trans}

Следующим критерием является ~\ref{item:criteria:sound-trans} ---
корректность трансформаций, то есть правил переписывания 
исходного кода, применяемых в компиляторных оптимизациях. 

\emph{Корректная} трансформация должна сохранять семантику программы. 
В нашем контексте, как и в случае корректности схемы компиляции,
это означает, что множество допустимых сценариев поведения 
программы после применения трансформации должно 
быть подмножеством допустимых сценариев поведения оригинальной программы.

Возвращаясь к примеру \ref{ex:sb},
снова рассмотрим модель последовательной согласованности 
и возьмём трансформацию, которая переставляет местами 
операции записи и  чтения в левом потоке, предполагая, 
что они оперируют различными локациями в памяти:

\begin{minipage}{0.45\linewidth}
\begin{equation*}
\inarrII{
   \writeInst{}{x}{1}   \\
   \readInst{}{r_1}{y}  \\
}{
  \writeInst{}{y}{1}   \\
  \readInst{}{r_2}{x}  \\
}
% \tag{SB}\label{ex:sb-src}
\end{equation*}
\end{minipage}\hfill%
\begin{minipage}{0.05\linewidth}
\Large~\\ $\leadsto$
\end{minipage}\hfill%
\begin{minipage}{0.45\linewidth}
\begin{equation*}
\inarrII{
   \readInst{}{r_1}{y}  \\
   \writeInst{}{x}{1}   \\
}{
  \writeInst{}{y}{1}   \\
  \readInst{}{r_2}{x}  \\
}
% \tag{SBtr}\label{ex:sb-tgt}
\end{equation*}
\end{minipage}

Для преобразованной версии программы (справа),
результат $[r_1=0, r_2=0]$ является последовательно согласованным. 
Тем не менее, для оригинальной версии программы (слева) это неверно. 
Следовательно, вышеупомянутая трансформация 
является некорректной для модели \SC. 

В следующих разделах мы рассмотрим  некоторые  трансформации,
обсуждаемые в различных исследованиях. 
Заметим, что этот список далеко не полон 
и не включает многие трансформации, 
выполняемые существующими оптимизирующими компиляторами~\cite{Muchnick:ACDI97}.
Например, он не включает трансформации над циклами,
так как в теории моделей памяти ещё недостаточно 
проработаны темы гарантий прогресса 
(\emph{liveness properties})~\cite{Lahav-al:arXiv20}, 
которые необходимы для формального 
изучения этих трансформаций. 

Трансформации, которые мы рассматриваем,  
разделены на два подкласса: \emph{локальные} и \emph{глобальные}.
Локальные трансформации модифицируют  
небольшой участок кода в пределах одного потока; 
глобальные трансформации задействуют  всю программу 
или её большую часть, захватывая несколько потоков.      
 
\subsubsection{Локальные трансформации}

\paragraph{
Переупорядочивание независимых инструкций
(Reordering of Independent Instructions).
} 

Эта трансформация переставляет местами  
две смежные инструкции, выполняющие обращение к 
различным адресам памяти. 
Выделяют  четыре типа переупорядочивания:
запись/чтение, запись/запись,
чтение/чтение и чтение/запись. 
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{cccl} 

      \writeInst{}{x}{v} \seq \readInst{}{r}{y} 
    & \leadsto 
    & \readInst{}{r}{y} \seq \writeInst{}{x}{v}
    & \text{store/load, SL}  \\ 

      \writeInst{}{x}{v} \seq \writeInst{}{y}{u} 
    & \leadsto 
    & \writeInst{}{y}{u} \seq \writeInst{}{x}{v}
    & \text{store/store, SS}  \\ 

      \readInst{}{r}{x} \seq \readInst{}{s}{y} 
    & \leadsto 
    & \readInst{}{s}{y} \seq \readInst{}{r}{x}
    & \text{load/load, LL}  \\ 

      \readInst{}{r}{x} \seq \writeInst{}{y}{v} 
    & \leadsto 
    & \writeInst{}{y}{v} \seq \readInst{}{r}{x}
    & \text{load/store, LS}  \\ 

  \end{array}
\]

\paragraph{
Элиминация избыточного обращения
(Elimination of Redundant Access).
} 

В паре двух смежных обращений к памяти
одно из них может быть удалено, 
если его эффект покрывается другим. 
Например, две операции записи в одну и ту же переменную 
одного и того же значения могут быть заменены 
на одну операцию записи. 
Аналогично переупорядочиванию инструкций, 
выделяют четыре класса трансформация этого вида.  
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{cccl} 

      \writeInst{}{x}{v} \seq \readInst{}{r}{x} 
    & \leadsto 
    & \writeInst{}{x}{v} \seq \assignInst{r}{v}
    & \text{store/load, SL}  \\ 

      \readInst{}{r}{x} \seq \readInst{}{s}{x} 
    & \leadsto 
    & \readInst{}{r}{x} \seq \assignInst{s}{r}
    & \text{load/load, LL}  \\ 

      \readInst{}{r}{x} \seq \writeInst{}{x}{r} 
    & \leadsto 
    & \readInst{}{r}{x} 
    & \text{load/store, LS}  \\ 

      \writeInst{}{x}{v} \seq \writeInst{}{x}{u} 
    & \leadsto 
    & \writeInst{}{x}{u}
    & \text{store/store, SS}  \\ 

  \end{array}
\]

\paragraph{
Элиминация нерелевантной операции чтения
(Irrelevant Load Elimination, ILE).
}

Эта трансформация удаляет инструкцию чтения, 
если её результат не используется в программе. 
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{cccl} 

      \readInst{}{r}{x} 
    & \leadsto 
    & \epsInst
    & ~|~ \text{$r$ is never used}  \\ 

  \end{array}
\]

\paragraph{
Введение спекулятивной операции чтения
(Speculative Load Introduction, SLI).
}

Эта трансформация является обратной к предыдущей и вставляет инструкцию чтения в произвольное место программы.
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{cccl} 

      \epsInst
    & \leadsto 
    & \readInst{}{r}{x} 
    & ~|~ \text{$r$ is never used}  \\ 

  \end{array}
\]

В комбинации с элиминацей типа чтение/чтение 
эта трансформация может быть использована 
для того, чтобы вынести чтение из 
ветки условного оператора:
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{ccc} 

      \kw{if} (e)~ \kw{then} \{ \readInst{}{r}{x} \}
    & \leadsto 
    & \readInst{}{s}{x} \seq \kw{if} (e)~ \kw{then} \{ \assignInst{r}{s} \} \\
    & & ~|~ \text{$s$ is never used}  \\ 

  \end{array}
\]

\paragraph{
Переупорядочивание с увеличением синхронизации
(Roach Motel Reordering, RM).
}

Этот класс трансформаций позволяет вносить дополнительные инструкции в блоки синхронизации. 
Например, инструкция записи может быть 
перенесена в критическую секции, то есть
переставлена за следующую операцию захвата блокировки. 
Интуитивно, такие перестановки могут 
только увеличить степень синхронизацию в программе, 
то есть преобразованная программа 
должна обладать меньшим недетерминизмом 
и иметь меньшее количество допустимых сценариев поведения. 

Неатомарные обращения могут быть внесены 
в критическую секцию без дополнительных предусловий. 
Кроме того, инструкция записи может быть перемещена после 
операции захвата блокировки, а инструкция чтения 
может быть перемещена до операции освобождения блокировки. 
Похожие правила применяются к перестановке операций вокруг 
захватывающих (\emph{acquire}) и освобождающих (\emph{release}) 
обращений к памяти. 
% %
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{cccl} 

      \readInst{\na}{r}{x} \seq \lockInst{l} 
    & \leadsto 
    & \lockInst{l} \seq \readInst{\na}{r}{x}
    & ~ \\ 

      \writeInst{o}{x}{v} \seq \lockInst{l} 
    & \leadsto 
    & \lockInst{l} \seq \writeInst{o}{x}{v}
    & ~  \\ 

      \unlockInst{l} \seq \writeInst{\na}{x}{v} 
    & \leadsto 
    & \writeInst{\na}{x}{v} \seq \unlockInst{l}
    & ~ \\ 


      \unlockInst{l} \seq \readInst{o}{r}{x} 
    & \leadsto 
    & \readInst{o}{r}{x} \seq \unlockInst{l}
    & ~  \\ 

  \end{array}
\]


\paragraph{
Усиление обращений к памяти
(Strengthening, S).
}

Данная трансформация, подобно предыдущей, 
увеличивает степень синхронизации в программе 
путем усиления режима обращения к памяти.
Например, неатомарное обращение к переменной  может быть заменено на 
последовательно согласованное: 
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{cccl} 

      \readInst{o}{r}{x} 
    & \leadsto 
    & \readInst{o'}{r}{x}
    & ~|~ o \sqsubset o' \\ 

      \writeInst{o}{x}{v}
    & \leadsto 
    & \writeInst{o'}{x}{v}
    & ~|~ o \sqsubset o'  \\ 

  \end{array}
\]

\paragraph{
Трансформации, сохраняющие трассы
(Trace Preserving Transformations, TP).
}

Этот широкий класс трансформаций, который включает трансформации, 
не меняющие множество трасс потока~\cite{Sevcik-Aspinall:ECOOP08}.
Трассой называется последовательность видимых побочных эффектов,
возникающих во время исполнения кода потока, при этом 
операции чтения и записи в разделяемую память тоже считаются эффектами.
Классическим примером подобной трансформации является \emph{распространение констант}%
~\cite{Muchnick:ACDI97, Wegman-Zadeck:TOPLAS91}.
Ниже приведен пример применения данной трансформации. 
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{cccl} 

      \writeInst{}{x}{0 + v} 
    & \leadsto 
    & \writeInst{}{x}{v}
    & \\ 

  \end{array}
\]
  
\paragraph{
Удаление общих подвыражений
(Common Subexpression Elimination, CSE).
}

\CSE является ещё одной классической трансформацией~\cite{Muchnick:ACDI97}, 
которая выполняет поиск и удаление идентичных подвыражений.
Вот пример выполнения этой трансформации:
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{cccl} 

      \readInst{}{r_1}{x + y} \seq \readInst{}{r_2}{x + y} 
    & \leadsto 
    & \readInst{}{r_1}{x + y} \seq \readInst{}{r_2}{r_1}
    & \\ 

  \end{array}
\]

\subsubsection{Глобальные трансформации}

\paragraph{
Продвижение регистров
(Register Promotion, RP).
}

Если компилятор может определить, что 
обращения к разделяемой переменной 
происходят только из одного потока,
тогда он может заменить все обращения к этой переменной 
на обращения к регистру.
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{ccl} 

      \writeInst{}{x}{v} \seq \readInst{}{r}{x} 
    & \leadsto 
    & \assignInst{s}{v} \seq \assignInst{r}{s}
    \\ 
    
    & & |~ \text{\texttt{x} is not accessed from other threads} \\
    & & |~ \text{\texttt{s} is a fresh register} \\ 

  \end{array}
\]

\paragraph{Слияние потоков (Thread Inlining, TI).}

Эта трансформация объединяет два потока в один.
Оказывается, что эта на первый взгляд простая и очевидная
трансформация не является корректной в некоторых моделях памяти. 
%
\[\def\arraystretch{1.4}\footnotesize
  \begin{array}{cccl} 

      P \pll Q 
    & \leadsto 
    & P ~\seq Q
    & ~ \\ 
    
  \end{array}
\]


\paragraph{
Трансформации, основанные на анализе диапазона значений
(Value Range Based Transformations, VR).
}

Трансформации этого класса могут быть применены в случае,
если программа удовлетворяет некоторому инварианту,
выведенному с помощью глобального анализа 
диапазона возможных значений переменных.
Например, в программе ниже условный оператор
может быть удален, так как статический 
анализ может вывести инвариант 
$\mathsf{x} \geq \mathsf{0}$.

{\footnotesize
\begin{minipage}{0.45\linewidth}
\begin{equation*}
\inarrII{
   \readInst{}{r_1}{x}             \\
   \kw{if} (r_1 \geq 0) ~\kw{then} \\
   \quad\writeInst{}{y}{1}         \\
}{
  \readInst{}{r_2}{x}               \\
  \writeInst{}{y}{r_2}              \\
}
\end{equation*}
\end{minipage}\hfill%
\begin{minipage}{0.05\linewidth}
\Large~\\ $\leadsto$
\end{minipage}\hfill%
\begin{minipage}{0.4\linewidth}
\begin{equation*}
\inarrII{
   \readInst{}{r_1}{x}             \\
   \writeInst{}{y}{1}              \\
}{
  \readInst{}{r_2}{x}               \\
  \writeInst{}{y}{r_2}              \\
}
\end{equation*}
\end{minipage}
}

\subsection{Гарантии}

Далее мы обсуждаем третий критерий~\ref{item:criteria:reasoning} ---
гарантии о поведении программ, предоставляемые моделью памяти.

\subsubsection{\DRF-свойство}
\label{sec:background:drf}

При рассуждении о многопоточных программах  
большинство программистов подразумевают 
модель последовательной согласованности. 
Действительно, было бы неправильно ожидать
от программистов знания всех деталей слабых моделей, 
так как это только усложнило бы и без того 
непростую задачу проектирования и разработки
многопоточных программ. 
Для того чтобы решить эту проблему, 
было предложено свойство \emph{свободы от гонок}
(\emph{data-race freedom}, \DRF)~\cite{Manson-al:POPL05}.
Это свойство гарантирует, что при наличии 
достаточной степени синхронизации программа будет иметь 
только последовательно согласованные сценарии поведения в слабой модели памяти. 
Другими словами, если слабая модель памяти обладает \DRF-свойством, 
то при условии правильного использования примитивов синхронизации
программист может не задумываться о слабых сценариях поведения 
и подразумевать модель последовательной согласованности.

Рассмотрим пример. 
Вернемся к программе \ref{ex:sb} из \cref{sec:background:compile}.
Как было продемонстрировано ранее, в слабой модели 
эта программа может допускать результат ${[r_1=0, r_2=0]}$.
Тем не менее, семантика последовательной согласованности
может быть восстановлена, например, при помощи блокировок, 
как показано в примере ниже:

\begin{equation*}
\inarrII{
   \lockInst{l}         \\
   \writeInst{}{x}{1}   \\
   \readInst{}{r_1}{y}  \\
   \unlockInst{l}       \\
}{
   \lockInst{l}         \\
   \writeInst{}{y}{1}   \\
   \readInst{}{r_2}{x}  \\
   \unlockInst{l}       \\
}
\tag{SB+LOCK}\label{ex:sb-lock}
\end{equation*}

Совместимая с \DRF-свойством слабая модель памяти должна гарантировать, 
что для программы выше допустимы только 
последовательно согласованные сценарии поведения с результатами
${[r_1=0, r_2=1]}$, ${[r_1=1,r_2=0]}$ или ${[r_1=1,r_2=1]}$.

Если модель предоставляет последовательно согласованный 
режим доступа, тогда программист также может 
аннотировать все обращения к переменным как последовательно согласованные
и таким образом восстановить семантику \SC:
 
\begin{equation*}
\inarrII{
   \writeInst{\sco}{x}{1}   \\
   \readInst{\sco}{r_1}{y}  \\
}{
   \writeInst{\sco}{y}{1}   \\
   \readInst{\sco}{r_2}{x}  \\
}
\tag{SB+SC}\label{ex:sb-sc}
\end{equation*}

Более формально, \DRF-свойство для слабой модели $M$
утверждает, что если программа не содержит гонок в модели 
последовательной согласованности, тогда модель $M$
допускает только последовательно согласованные 
сценарии поведения для этой программы.

Итак, свойство \DRF позволяет свести рассуждения о поведении программы 
в слабой модели к рассуждениям в модели последовательной согласованности.
Достаточно лишь показать, что программа не имеет гонок 
в модели \SC, чтобы иметь факт, что она будет иметь только \SC 
сценарии поведения в слабой модели. 

Свойство \DRF в приведенной  выше формулировке иногда также называется
\emph{внешней свободой от гонок} (\eDRF), 
чтобы отличать его от \emph{внутренней свободы от гонок} (\iDRF).
\iDRF-свойство гарантирует для программы семантику \SC
в слабой модели $M$ только в случае, если программа 
не имеет гонок в самой модели $M$.
Это свойство предоставляет более слабую гарантию
по сравнению с внешней свободой от гонок. 
Оно не позволяет полностью избежать рассуждений 
в терминах слабой модели, так как 
сначала необходимо показать, что программа не имеет гонок именно в слабой модели. 
Как будет продемонстрировано далее (\emph{см.} \cref{sec:analysis:oota}), 
внутренняя свобода от гонок является компромиссом 
для определенного класса моделей, которые не могут 
предоставить внешнюю свободу от гонок. 

\subsubsection{Когерентность (COH)}
\label{sec:background:coh}

Как было показано раньше, современные процессоры
не гарантируют выполнимость модели последовательной согласованности. 
Тем не менее, обычно они предоставляют более слабую 
гарантию \emph{последовательной согласованности 
по каждой локации в памяти}, именуемую также 
\emph{когерентностью}~\cite{Alglave-al:TOPLAS14}. 
Соответственно, модели памяти 
для языков программирования также зачастую предоставляют эту гарантию.

Когерентность гарантирует, что все операции записи 
по определенному адресу памяти будут полностью упорядочены,
и что получающийся в результате \emph{порядок когерентности} 
(\emph{coherence order}) отражает порядок, 
в котором эффекты от операций записи, выполненных некоторым потоком, 
отражаются в основной памяти, и их результаты становятся видимыми для других потоков.
В частности, из свойства когерентности следует, 
что программа, состоящая из обращений только 
к одной локации в памяти, должна 
обладать семантикой последовательной согласованности.
Например, рассмотрим следующую программу:

\begin{equation*}
\inarrII{
   \writeInst{}{x}{1}   \\
   \readInst{}{r_1}{x}  \\
}{
   \writeInst{}{x}{2}   \\
   \readInst{}{r_2}{x}  \\
}
\tag{COH}\label{ex:coh}
\end{equation*}

Наличие свойства когерентности предписывает модели памяти 
допускать для этой программы только последовательно 
согласованные сценарии поведения с результатами
${[r_1=1, r_2=2]}$, ${[r_1=1, r_2=1]}$ или ${[r_1=2, r_2=2]}$.
Для модели, не удовлетворяющей свойству когерентности, 
допустимым также является результат ${[r_1=2, r_2=1]}$.
Например, модель памяти \Java допускает подобный сценарий поведения~\cite{Manson-al:POPL05}.

\subsubsection{Неопределенное поведение (no-UB)}
\label{sec:background:ub}

Как мы уже кратко упоминали, некоторые модели памяти, например, \CPP, рассматривают программы с гонками на неатомарных обращениях как имеющие 
\emph{неопределенное поведение}~\cite{Boehm-Adve:PLDI08}.
Другими словами, для таких программ любой сценарий поведения считается допустимым. 
Это свойство также иногда называется 
\emph{возгорающейся семантикой} (\emph{catch-fire semantics}).
 
Практическая польза такого подхода заключается в том,
что он допускает оптимальную схему компиляции для 
неатомарных обращений и позволяет применять к ним 
любые оптимизации, корректные для последовательных программ.
Дело в том, что эффекты от оптимизаций, осуществляемых процессором или компилятором, могут наблюдаться только при обращении к переменным из параллельных потоков. 
Если таким обращениям предписывается неопределенное поведение и на них 
не распространяются никакие гарантии, то тогда эффекты этих оптимизаций 
становятся неразличимы с точки зрения семантики программы. 
 
\subsubsection{Спекулятивное исполнение (In-Order) и значения из воздуха (no-OOTA)}
\label{sec:background:oota}

Чтобы представить последние два свойства, 
а именно, наличие спекулятивного исполнения и значений из воздуха, 
мы рассмотрим ещё один пример:

\begin{equation*}
\inarrII{
  \readInst{}{r_1}{x}     \\
  \writeInst{}{y}{1}      \\
}{
  \readInst{}{r_2}{y}     \\
  \writeInst{}{x}{r_2}    \\
}
\tag{LB}\label{ex:lb}
\end{equation*}

Предположим, что модель памяти допускает 
результат ${[r_1=1, r_2=1]}$ для этой программы. 
Например, модели семейств процессоров 
\ARMv{7}, \ARMv{8} и \POWER
допускают  сценарий поведения, ведущий к такому результату, 
и этот сценарий может наблюдаться на некоторых процессорах семейства 
\ARMv{7}~\cite{Maranget-al:Tutorial2012}.

Результат ${[r_1=1, r_2=1]}$ не может быть получен 
путем исполнения инструкции согласно их порядку внутри потоков (\emph{in-order execution}).
Чтобы получить подобное поведение, 
модель памяти должна  использовать 
некоторую форму \emph{спекулятивного исполнения}
(\emph{speculative execution})~\cite{Boudol-Petri:ESOP10, Boehm-Demsky:MSPC14}.
Это означает, что  операция чтения $\readInst{}{r_1}{x}$
должна быть буферизована, а операция записи $\writeInst{}{y}{1}$ 
должна выполнится вне очереди 
(отсюда и название программы выше --- 
буферизация операции чтения \emph{load buffering}).

Однако неограниченные спекуляции могут привести 
к нежелательным последствиям. 
Операция записи, исполненная вне очереди, может обернуться
самоисполняющемся пророчеством (self-fulfilling prophecy)~\cite{Boehm-Demsky:MSPC14}. 
Рассмотрим следующий вариант программы с буферизацией операции чтения:

\begin{equation*}
\small
\inarrII{
  \readInst{}{r_1}{x}   \\
  \writeInst{}{y}{r_1}  \\
}{
  \readInst{}{r_2}{y}   \\
  \writeInst{}{x}{r_2}  \\
}
\tag{LB+data}\label{ex:lb+data}
\end{equation*}

Здесь гипотетическая абстрактная машина 
может спекулятивно исполнить операцию записи в переменную \texttt{y}
значения \texttt{1} в левом потоке, 
затем прочитать это значение в правом потоке, 
записать его в переменную \texttt{x} и прочитать обратно из 
первого потока, таким образом сформировав парадоксальный цикл 
причинно-следственных связей.  
Значение \texttt{1} в примере выше появляется \emph{из воздуха}
(\emph{out of thin-air}) и приводит 
к неожиданному результату ${[r_1=1, r_2=1]}$.

Как будет показано в \cref{sec:analysis},
возможность спекулятивного исполнения необходима для того, чтобы 
поддержать в модели памяти некоторый класс трансформаций программ. 
Тем не менее, спекулятивное исполнения необходимо 
ограничить должным образом, чтобы избежать 
появления значений из воздуха. 
В \cref{sec:analysis:porf,sec:analysis:deprf,sec:analysis:sdeprf}
мы рассмотрим то, как эта проблема решается в различных моделях памяти. 
