\section{Рекомендации по выбору модели}
\label{sec:discussion}

В этом разделе мы  представляем краткий набор рекомендации для 
исследователей и системных разработчиков 
по выбору модели памяти на основе дизайна языка программирования.

Для языков, которые стремятся предоставить простую семантику 
и высокоуровневые абстракции ценой некоторых потерь в 
производительности, целесообразно использовать простые модели памяти, такие как 
модель последовательной согласованности. 

Языки программирования, фокусирующиеся на 
эффективности производимого кода, 
такие как \CPP, в свою очередь, вынуждены 
прибегать к наиболее слабым моделям, 
допускающим оптимальные схемы компиляции и 
широкий набор трансформаций кода. 
Для этих языков целесообразно использовать
модели, сохраняющие семантические зависимости. 
Однако данные модели являются наиболее сложными, 
что существенно затрудняет рассуждения о 
корректности программ~\cite{Svendsen-al:ESOP18}. 

Между двумя этими крайними вариантами  находятся модели, 
сохраняющие программный порядок или синтаксические зависимости. 
Их целесообразно использовать для языков программирования, 
которые могут позволить умеренные накладные 
расходы на производительность в обмен 
на чуть более простое и предсказуемое поведение~\cite{Ou-Demsky:OOPSLA18}. 

Более того, модели, сохраняющие программный порядок, 
имеют дополнительное преимущество перед моделями, 
сохраняющими синтаксические или семантические зависимости: они не требуют использования 
спекулятивного исполнения. 
Этот факт eщё больше упрощает рассуждение о корректности 
многопоточных программ и лучше отражает ожидание программистов. 
Ценой этой простоты является требование к моделям, сохраняющим программный порядок, 
использовать субоптимальные схемы компиляции 
для процессоры семейств \ARM и \POWER.
С другой стороны, модели, сохраняющие синтаксические зависимости, 
позволяют эффективно компилировать код для процессоров \ARM и \POWER. Однако
эти модели не поддерживают ряд трансформаций, 
сохраняющих трассы, например, распространение констант. Они также используют спекулятивное исполнение, 
что приводит к более сложной семантике.  

Для языков программирования, использующих более строгие модели памяти, 
которые требуют использования неоптимальных схем компиляции 
и запрещают применение некоторых трансформации, 
существует несколько общих техник оптимизации, 
помогающих частично смягчить возникающие накладные расходы. 

Система типов может существенно помочь в этом. 
Здесь преимущество имеют такие языки как \Haskell, \OCaml, \Rust, 
которые статически различают и изолируют регионы памяти, 
к которым возможны обращения из параллельных потоков. 
Эти языки могут точно идентифицировать переменные, неизменяемые и локальные для одного потока, 
а затем компилировать обращения к таким переменным без использования барьеров. 
Более того, при обращении к этим переменным 
можно применять широкий класс трансформаций кода, 
корректных для случая однопоточных программ.
 
Такие языки программирования как  \Java не могут
использовать систему типов для предотвращения 
доступа к неатомарным переменным из параллельных потоков
из-за обратной совместимости.
Тем не менее подобные языки
могут аппроксимировать множество локальных переменных потоков,  используя консервативный 
статический анализ достижимости переменных 
(escape analysis)~\cite{Choi-al:OOPSLA1999}, 
или различные динамические техники~\cite{Liu-al:PLDI19},
а затем оптимизировать обращения к этим переменным.  

В функциональных языках программирования активно используются  неизменеямые структуры данных. Этот стиль программирования минимизирует
использование разделяемой памяти и помогает 
уменьшить накладные расходы, вызванные 
строгой моделью памяти~\cite{Vollmer-al:PPoPP17}.  

Наконец, если язык допускает наличие неопределенного поведения, 
например, как язык \CPP, тогда альтернативой сложной модели, 
сохраняющей синтаксические зависимости, 
может служить более простая модель, сохраняющая программный порядок, 
и рассматривающая гонки на неатомарных обращениях как 
неопределенное поведение~\cite{Boehm-Demsky:MSPC14, Ou-Demsky:OOPSLA18}.
В этом случае компилятор может использовать оптимальные 
схемы компиляции и широкий спектр трансформаций  к неатомарным обращениям
и в то же время предоставлять относительно простую семантику для атомарных обращений. 

\paragraph{Выбор моделия для языка \Kotlin.}

Рассмотрим в качестве примера \Kotlin\footnote{https://kotlinlang.org/}, который является языком программирования общего назначения и не имеет ещё стандартизированной модели памяти. 
На текущий момент \Kotlin  компилируется  в байткод виртуальной машины \Java, в код \JS, 
или в нативный код средствами \LLVM
(для платформ Linux, Windows, macOS, iOS и др.).

Язык не ориентирован на системное программирование, 
то есть он не обязан предоставлять абстракции с нулевой стоимостью
для обращений к разделяемой памяти целевой архитектуры. 
То есть модель память, сохраняющая программный порядок 
или синтаксические зависимости, подходит для \Kotlin. 
Оба подхода ведут к умеренным накладным расходам 
на время работы программ. 
Однако модели памяти, сохраняющие программный порядок,
лучше подходят для языков, допускающих неопределенное поведение
для программ с гонками на неатомарных переменных
(\see~\cite{Ou-Demsky:OOPSLA18}), 
так как в этом случае можно компилировать неатомарные обращения
как обычные инструкции обращения к памяти для архитектур процессоров \ARM и \POWER.
Несмотря на то, что наличие неопределенного поведения в языке 
\Kotlin в общем нежелательно, на практике это труднодостижимо, 
так как гонки на неатомарных переменных уже имеют 
неопределенное поведение в \LLVM~\cite{Chakraborty-Vafeiadis:CGO17},
а \LLVM является одной из целевых платформ языка \Kotlin.

Среди класса моделей, сохраняющих программный порядок, наиболее 
хорошо изучена и полна с точки зрения поддержки 
различных примитивов  модель \RCMM~\cite{Lahav-al:PLDI17}. Она  
является  модифицированной версией модели \CMM~\cite{Batty-al:POPL11}, 
в которую было добавлено сохранение программного порядка.
\RCMM поддерживает надмножетсво режимов обращения к разделяемой памяти, 
доступных в \JMM~\cite{Manson-al:POPL05} и её расширении \JAM~\cite{Bender-Palsberg:OOPSLA19}. Эта модель очень близка к моделям памяти 
\JS~\cite{Watt-al:PLDI2020} и \LLVM~\cite{Chakraborty-Vafeiadis:CGO17}, 
так как обе эти модели основываются на  \CMM.

Все это делает модель \RCMM хорошей отправной точкой для разработки модели памяти для \Kotlin.

