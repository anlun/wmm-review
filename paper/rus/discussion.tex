\section{Рекомендации по выбору модели}
\label{sec:discussion}

В этом разделе мы приводим резюме проделанного анализа  
и представляем краткий набор рекомендации для 
исследователей и системных разработчиков 
по выбору модели памяти на основе дизайна языка программирования.

Для языков, которые стемятся предоставить простую семантику 
и высокоуровневые абстракции ценой некоторых потерь в 
производительности, наиболее логичным выбором 
будут простые модели памяти, такие как 
модель последовательной согласованности. 

Языки программирования, фокусирующиеся на 
эффективности производимого кода, 
такие как \CPP, в свою очередь, вынуждены 
прибегать к наиболее слабым моделям, 
допускающим оптимальные схемы компиляции и 
широкий набор трансформаций кода. 
Для этих языков логичным выбором являются 
модели, сохраняющие семантические зависимости. 
Однако данные модели являются наиболее сложными, 
что существенно затрудняет рассуждения о 
корректности программ~\cite{Svendsen-al:ESOP18}. 

Между двумя крайностями находятся модели, 
сохраняющие программный порядок или синтаксические зависимости. 
Они являются разумным выбором для языков, 
которые могут позволить умеренные накладные 
расходы на производительность в обмен 
на чуть более простое и предсказуемое поведение~\cite{Ou-Demsky:OOPSLA18}. 

Более того, модели, сохраняющие программный порядок, 
имеют дополнительное преимущество перед моделями, 
сохраняющими синтаксические или семантические зависимости, 
заключающееся в том, что они не требуют использования 
спекулятивного исполнения. 
Этот факт eщё больше упрощает рассуждение о корректности 
многопоточных программ и лучше отражает ожидание программистов. 
Ценой этой простоты является тот факт, 
что модели, сохраняющие программный порядок, 
требуют использовать суб-оптимальные схемы компиляции 
под процессоры семейств \ARM и \POWER.
С другой стороны, модели, сохраняющие синтаксические зависимости, 
позволяют эффективно компилировать код под процессоры \ARM и \POWER,
но эти модели не поддерживают некоторые трансформации, 
сохраняющие трассы, например, распространение констант, 
а также используют спекулятивное исполнение, 
что приводит к более сложной семантике.  

Для языков, выбирающих более строгие модели памяти, 
которые требуют использования неоптимальных схем компиляции 
и запрещают применение некоторых трансформации, 
существует несколько общих техник оптимизации, 
помогающих частично смягчить возникающие накладные расходы. 

Система типов может существенно помочь в этом. 
Преимущество имеют такие языки как \Haskell, \OCaml, \Rust, 
которые статически различают и изолируют регионы памяти, 
к которым возможны обращения из параллельных потоков. 
Эти языки могут точно идентифицировать неизменяемые 
и локальные для одного потока переменные, 
а затем компилировать обращения к таким переменным 
без использования барьеров. 
Более того, к обращениям к этим переменным 
можно применять широкий класс трансформаций кода, 
корректных для случая однопоточных программ. 
 
Языки программирования вроде \Java не могут
использовать систему типов для предотвращения 
доступа к неатомарным переменным из параллельных потоков
из-за обратной совместимости.
Тем не менее эти языки
могут аппроксимировать множество локальных 
для потоков переменных использую консервативный 
статический анализ достижимости переменных 
(escape analysis)~\cite{Choi-al:OOPSLA1999}, 
или различные динамические техники~\cite{Liu-al:PLDI19},
а затем оптимизировать обращения к этим переменным.  

Функциональные языки программирования поощрают 
использование неизменеямых структур данных когда 
это возможно. Этот стиль программирования минимизирует
использование разделяемой памяти и помогает 
уменьшить накладные расходы вызванные 
строгой моделью памяти~\cite{Vollmer-al:PPoPP17}.  

Наконец, если язык допускает наличие неопределенного поведения, 
например, как язык \CPP, тогда альтернативой сложной модели, 
сохраняющей синтаксические зависимости, 
может служить более простая модель, сохраняющая программный порядок, 
и рассматривающая гонки на неатомарных обращениях как 
неопределенное поведение~\cite{Boehm-Demsky:MSPC14, Ou-Demsky:OOPSLA18}.
В этом случае компилятор может использовать оптимальные 
схемы компиляции и широкий спектр трансформаций приминительно к неатомарным обращениям,
и в то же время предоставлять относительно простую семантику 
для атомарных обращений. 

\paragraph{Выбор моделия для языка \Kotlin}

Рассмотрим в качестве примера \Kotlin,\footnote{https://kotlinlang.org/} --- 
язык программирование общего назначения, который ещё 
не имеет стандартизированной модели памяти. 
На текущий момент \Kotlin может быть скомпилирован 
в байткод виртуальной машины \Java, в код \JS, 
или в нативный код через \LLVM
(для платформ Linux, Windows, macOS, iOS, и других).

Язык не ориентирован на системное программирование, 
то есть он не обязан предоставлять абстракции с нулевой стоимостью
над обращениями к разделямой памяти целевой архитектуры. 
То есть модель память, сохраняющая программный порядок 
или синтаксические зависимости, подходит для \Kotlin. 
Оба подхода ведут к умеренным накладным расходам 
на время работы программ. 
Однако модели памяти, сохраняющие программный порядок
лучше подходят для языков, допускающих неопределенное поведение
для программ с гонками на неатомарных переменных
(\see~\cite{Ou-Demsky:OOPSLA18}), 
так как в этом случае допустимо компилировать неатомарные обращения
как обычные инструкции обращения к памяти на архитектурах 
процессоров \ARM и \POWER.
Несмотря на то, что наличие неопределенного поведения в языке 
\Kotlin в общем нежелательно, на практике это труднодостижимо, 
так как гонки на неатомарных переменных уже имеют 
неопределенное поведение в \LLVM~\cite{Chakraborty-Vafeiadis:CGO17}
(а \LLVM является одной из целевых платформ языка \Kotlin).

Среди класса моделей, сохраняющих программный порядок, наиболее 
хорошо изученная и полная с точки зрения поддержки 
различных примитивов это модель \RCMM~\cite{Lahav-al:PLDI17}, 
являющаяся модифицированной версией модели \CMM~\cite{Batty-al:POPL11}, 
в которую, собственно, было добавлено сохранение программного порядка.
\RCMM поддерживает надмножетсво режимов обращения к разделяемой памяти, 
доступных в \JMM~\cite{Manson-al:POPL05} и её расширении \JAM~\cite{Bender-Palsberg:OOPSLA19}, 
и она очень близка к моделям памяти 
\JS~\cite{Watt-al:PLDI2020} и \LLVM~\cite{Chakraborty-Vafeiadis:CGO17}, 
так как обе эти модели были вдохновлены \CMM.

Все это делает модель \RCMM хорошей отправной точкой для разработки модели памяти \Kotlin.

