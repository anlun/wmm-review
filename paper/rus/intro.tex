\section{Introduction}
\label{sec:intro}

Главная трудность конкурентного программирования 
заключается в обеспечении необходимого уровня 
синхронизации между конкурентно исполняемыми потоками программы. 
Обычно, это достигается при помощи специальных 
примитивов синхронизации предоставляемых 
языком программирования или библиотеками, 
такими как блокировки, барьеры, каналы \etc. 
Тем не менее, иногда использование этих примитивов 
невозможно или нежелательно. 
Например, код непосредственно реализующий эти 
примитивы не может на них полагаться. 
Другой важный пример это неблокирующие (lock-free) структуры данных.
В таких случаях необходимо обращаться к 
низкоуровневому программированию и 
взаимодействовать с разделяемой памятью напрямую.
Здесь начинаются сложности. 

Рассмотрим конкретный пример.
Ниже представлена упрощенная версия 
алгоритма блокировки Деккера:

\begin{equation*}
\inarrII{
  \writeInst{}{x}{1} \\
  \readInst{}{r_1}{y}  \\
  \kw{if} {r_1 = 0} ~\{ \\
  ~~ \comment{critical section} \\
  \}
}{
  \writeInst{}{y}{1} \\
  \readInst{}{r_2}{x}  \\
  \kw{if} {r_2 = 0} ~\{ \\
  ~~ \comment{critical section} \\
  \}
}
\tag{Dekker's Lock}\label{ex:Dekker}
\end{equation*}

В этой программе два потока соревнуются за доступ к критической секции.
Чтобы обозначить свое намерение войти в критическую секцию
потоки устанавливают значение переменных $x$ и $y$ соответственно.%
\footnote{В этой статье мы отличаем разделяемые переменные,
обозначаемые буквами $x$, $y$, $z$, и 
локальные для каждого потока регистры, 
обозначаемые как $r_1$, $r_2$, $r_3$, \etc.}
Поток, который первым установит значение переменной и 
прочитает значение другой переменной до его установки
получает право войти в критическую секцию.
Алгоритм полагается на тот факт, что оба 
потока не могут одновременно прочитать значение ~\texttt{0}.%
\footnote{С этого места и далее в статье мы подразумеваем 
что переменные инициализированы значением 0, если иное не указано явно.}
В противном случае два потока способны одновременно 
войти в критическую секции, таким образом нарушая 
гарантии корректности алгоритма. 

В самом деле, можно было бы ожидать что эта программа 
должна завершиться с одним из следующих результатов: 
${[r_1=0, r_2=1]}$, ${[r_1=1,r_2=0]}$, or ${[r_1=1,r_2=1]}$,
называемых \emph{последовательно согласованными} 
(\emph{sequential consistent})~\cite{Lamport:TC79},
то есть полученных в результате поочередного 
исполнения инструкции потоков. 

%A memory model that admits only these behaviours is known under the name \emph{sequential consistency} (SC) [Lamport:TC79].

%% ANTON: If we have enough space, I'd put a figure w/ the interleavings.)
%% ANTON: IMO, we should more carefully distinguish terms "behavior" and "outcome".
%% ANTON: Also, we should state somewhere that, in the context of concurrent programs, 
%%        we use terms "semantics" and "memory model" interchangeably.

Тем не менее, не все поведения наблюдаемые на настоящих
конкурентных системах являются последовательно согласованными.
Например, при портировании псевдокода алгоритма Деккера
на язык C, компиляции программы с помощью компилятора GCC, 
и запуска полученного кода на процессорах семейства x86/x64
можно также наблюдать не последовательно согласованное поведение
с результатом $[r_1=0, r_2=0]$, называемое слабым (\emph{weak}) поведением.

Слабые поведения появляются в результате оптимизаций 
компиляторов и процессоров. Например, 
рассматривая программу \ref{ex:Dekker}, 
оптимизатор может заметить, что запись в переменную $x$
и чтение из $y$ в левом потоке являются независимыми инструкциями 
и, следовательно, могут быть переупорядочены
(заметим, что эта оптимизация является корректной 
для случая однопоточных программ).
Для оптимизированной программы поведение с результатом
$[r_1=0, r_2=0]$ является последовательно согласованным.

Множество допустимых поведений программы определяется
семантикой многопоточной системы, или \emph{моделью памяти}.
Модель \emph{последовательной согласованности}
(\emph{sequential consistency}, SC) допускает 
только последовательно согласованные поведения.
Модели памяти также допускающие слабые поведения 
называются, соответственно, \emph{слабыми моделями памяти}
(\emph{weak memory models}).

Современные процессоры и языки программирования 
не предоставляют модель последовательной согласованности, 
так как она запрещает многие важные оптимизации.
Основной вопрос таким образом заключается в том, насколько слабой 
должна быть модель. Более строгая модель допускает меньше поведений, 
и, следовательно, предоставляет больше гарантии программисту.
С другой стороны, более слабая модель позволяет
выполнять большее количество оптимизаций.

Оказывается, что этот вопрос весьма сложен, 
особенно в контексте моделей памяти языков программирования (ЯП).
Это привело к тому, что за последнее 20 лет было предложено 
множество моделей для различных языков, например, для 
\Java~\cite{Manson-al:POPL05, Bender-Palsberg:OOPSLA19}, \CPP~\cite{Batty-al:POPL11}, 
\LLVM~\cite{Chakraborty-Vafeiadis:CGO17}, \JS~\cite{Watt-al:PLDI2020}, 
\OCaml~\cite{Manson-al:POPL05}, \Haskell~\cite{Vollmer-al:PPoPP17}, \etc
Эти модели имеют преследуют разные цели, делают различные компромиссы
и имеют разнообразные ограничения.
Более того, продолжают появляться новые исседования в области моделей памяти. 
По нашим подсчетам, за последние 10 лет в течении 
каждого года было опубликовано не менее 50 статей по теме.
\footnote{Эти подсчеты подкреплены данными, полученными 
с помощью поисковой системы Google Scholar, 
подробности представлены \cref{sec:methodology}.}
Тем не менее, несмотря на долгую историю и недавний прогресс в области,
нет единого источника, который бы суммировал 
известную информацию и сравнивал существующие 
модели памяти различных языков программирования. 
Целью данной статьи является создание такого обзора. 

Мы рассматриваем существующие модели памяти языков программирования, 
обсуждаем их дизайн, компромиссы и ограничения. 
Также мы сравниваем существующие модели на предмет того
какие оптимизации они поддерживают 
и какие гарантии предоставляют программистам. 

Мы надеемся, что наша работа будет полезна для 
исследователей в области языков программирования, 
желающих погрузиться в тему слабых моделей памяти, 
а также для разработчиков компиляторов и виртуальных машин, 
которым необходимо выбрать модель памяти для их системы.

Данная статья организована следующим образом. 
В секции \cref{sec:related} представлен обзор литературы. 
Далее мы описываем методологию нашего исследования \cref{sec:methodology}.
Затем мы вводим критерии сравнения моделей памяти \cref{sec:background}, 
в частности, оптимальность схем компиляции, 
корректность преобразований программ,
и предоставляемые гарантии для рассуждения 
о поведении программ.  
Далее мы описываем каким образом мы проводили 
сравнение моделей \cref{sec:comparison}. 
В разделе \cref{sec:analysis} мы классифицируем модели на основе их свойств
и обсуждаем каждый класс в отдельности. 
Также, в приложении \ref{sec:catalog} мы описываем каждую рассмотренную модель. 
Затем мы представляем набор рекомендации \cref{sec:discussion}
по выбору модели памяти на основе требования к языку программирования 
и рассматриваем их на примере языка Kotlin\footnote{https://kotlinlang.org/}.
Наконец, в разделе \cref{sec:conclusion} мы подводим итоги 
и рассматриваем возможные направления дальнейших исследований в области.
