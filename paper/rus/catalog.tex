\section{Catalog of Memory Models}
\label{sec:catalog}

В этом приложении мы погружаемся внутрь классов 
моеделей памяти, представленных в~\cref{sec:analysis},
и представляем более детальный взгляд на каждую модель памяти.
Этот раздел содержит краткий обзор каждой отдельной модели памяти, 
резюме её особенностей и свойств, а также ссылки на работы, 
посвященные этой модели.   
 
\subsection{Sequential Consistency}
\label{sec:catalog:sc}

Мы начинаем с разбора нескольких попыток 
адаптации модели последовательной согласованности 
в качестве модели памяти существующих языков программирования. 
Так как большинство предложенных решений имеют 
схожие свойства, в таблице \cref{table:cmp-mms} 
мы объединили их в одну строку с именем \SC. 
Исключением является только модель \DRFx,
которая реализует возгорающуюся семантику 
и таким образом несколько отличается от других моделей в данном классе. 

\paragraph{End-to-end Sequential Consistency}

В работах~\cite{Marino-al:PLDI11, Singh-al:ISCA12} 
изучались накладные расходы, необходимые для того, 
чтобы гарантировать модель последовательной согласованности, 
путем (1) модификации инфраструктуры компилятора \LLVM и 
(2) модификации процессоров семейства \Intel.
Чтобы уменьшить накладные расходы, вызванные строгой моделью памяти, 
авторы использовали наблюдение о том, что 
процессору необходимо гарантировать семантику \SC 
только для обращений к разделяемым изменяемым переменным. 
Чтобы классифицировать регионы памяти как 
локальные для одного потока, разделяемые неизменяемые 
и разделяемые изменяемые, авторы использовали 
комбинацию из статического анализа, выполняемого компилятором, 
и динамического анализа, полагающегося на аппаратную поддержку, 
реализованную в модифицированной версии процессора \Intel. 
Эксперименты показали, что в результате программы 
работают медленее на 6.2\% в среднем и ~17\% максимум, 
по сравнению с немодифицированной версией \LLVM
и оригинальной версией процессора \Intel.

\paragraph{Volatile-by-default}

В работах~\cite{Liu-al:OOPSLA17, Liu-al:PLDI19} изучалась 
модель последовательной согласованности в контексте языка \Java.
Авторы предложили так называемую \emph{volatile-by-default} семантику (\VbD),
которая по умолчанию рассматривает каждое обращение к памяти 
как изменяемое (\emph{volatile}), то есть как последовательно согласованное.  
Эксперименты показали, что этот подход ведет к значительному 
замедлению времени работы программ: 
при исполнении на процессорах семейства \Intel наблюдается 
замедление на 28\% в среднем и на 81\% максимум, 
а на процессорах семейства \ARMv{8}
на 57\% в среднем и на 157\% максимум. 
Авторы попробовали уменьшить накладные расходы и 
предложили новую технику оптимизации для обеспечения модели памяти \SC, 
совместимую с ``компиляцией на лету'' (\emph{just-in-time compilation}).
Они предложили спекулятивно рассматривать каждый объект 
как локальный для потока и компилировать все обращения 
к нему без использования барьеров памяти. 
Если далее в ходе исполнения программы виртуальная машина
обнаруживает обращения к этому объекту из других потоков, 
код доступа к этому объекту перекомпилируется, 
чтобы вставить необходимые барьеры памяти. 
Были проведены замеры времени работы программ
при исполнении на модифицированной версии \JVM,
которая реализует эту оптимизацию. 
В результате наблюдалось меньшее замедление времени работы программ, 
состовляющее 37\% в среднем и 73\% максимум на 
процессорах семейства \ARMv{8}.

\paragraph{SC-Haskell}

Модель памяти \SCHs~\cite{Vollmer-al:PPoPP17}
была вдохновлена схожими идеями, 
заключающимися в разделении локальной для потоков 
и разделяемой изменяемой памяти. 
Чтобы различать два типа памяти, 
авторы использовали систему типов языка \Haskell.
Вследствие этого разработчикам необходимо 
придерживаться более строгой дисциплины программирования, 
чтобы удовлетворить ограничения, накладываемые системой типов. 
Авторы модифицировали компилятор GHC чтобы 
гарантировать модель \SC, и затем 
замерили время работы 1,279 тестовых программ 
при исполнении на процессорах семейства \Intel. 
Согласно их данным, геометрическое среднее 
замедления времени работы составило 0.4\%, 
более того, только на 12 тестах 
наблюдалось замедление более чем на 10\%.
Эти многообещающие результаты частично объясняются тем 
фактом, что язык \Haskell поощрает 
использование функционального стиля программирования, 
который стремится минимизировать использование 
разделяемой изменяемой памяти. 

\paragraph{DRFx}

Модель \DRFx~\cite{Marino-al:PLDI10, Marino-al:TOPLAS2016} --- 
это ещё одна модель, гарантирующая семантику \SC.
В рамках данной модели гарантируется, что 
при обнаружении гонки система времени исполнения языка
генерирует исключение, а в случае отсутствия гонок 
гарантируется что сценарий исполнения программы будет последовательно согласованным.
Чтобы обеспечить работоспособность данной идеи на практике,
авторы предложили несколько модификаций для процессоров, 
обеспечивающих аппаратную поддержку обнаружения гонок.   

Авторы статьи утверждают, что любые трансформации, 
корректные для случая однопоточных программ, 
остаются корректными в модели \DRFx
(включая переупорядочивание инструкций и удаление общах подвыражений).
Единственное ограничение заключается в том, что 
это трансформации разрешено применять только 
внутри границ обозначенных компилятором регионов кода. 
Кроме того, любые трансформации, которые спекулятивно
добавляют операции чтения или записи, 
не являются корректными, 
так как они могут внести гонки в программы, 
которые ранее не содержали гонок.  

Отметим, что несмотря на заверения авторов о корректности широкого набора трансформаций, 
в \cref{table:cmp-mms} мы не помечаем многие из этих трансформаций как корректные, 
из-за соглашения, описаного в \cref{sec:comparison}.
Мы считаем трансформации корректными, только если 
они корректны в семантике, которая не трактует 
гонки как неопределенное поведение. 
Модель \DRFx не удовлетворяет этому требованию, 
так как в этой модели наличие гонки приводит 
к выбрасыванию исключения. 

При условии эффективной реализации 
аппаратного механизма обнаружения гонок в процессоре, 
ожидаемые накладные расходы на время работы программ 
для этой модели памяти состовляют 3.25\% в среднем
в сравнению с компиляцией немодифицированной версией компилятора
и исполнении на немодифицированной версии процессора \Intel.

\subsection{Total and Partial Store Order}

В этом разделе мы обсуждаем модели памяти 
разработанные на основе моделей \TSO и \PSO.

\paragraph{Buffered Memory Model}

В работе была предложена \emph{модель памяти с буфферизацией}
(\emph{Buffered Memory Model}, кратко \BMM), 
как модель памяти для языка \Java. 
Стоит отметить, что авторы не ставили перед собой задачи
полностью заменить модели памяти \Java, 
их целью была разработка верифицированной 
версии виртуальной машины \Java
(по аналогии с проектом CompCertTSO~\cite{Sevcik-al:JACM13} для языка C). 
Более простая, но тем не менее прагматичная модель, 
вдохнвленная моделью \TSO, рассматривалась 
как первый шаг на пути к этой цели. 

Авторы модели доказали корректность нескольких трансформаций
(включая переупорядочивание типа запись/чтение, 
спекулятивное введение чтения, и некоторых других, 
\see \cref{table:cmp-mms}), 
а также выполение свойства внешней свободы от гонок (\eDRF).
Также ими была модифицирована существующая реализация 
\JVM~\cite{Pizlo-al:ECCS10} и добавлена поддеркжа модели \BMM. 
Авторы сообщили о том, что в среднем замедление времени работы 
программ на модифицированной версии \JVM состовляет только~1\% в среднем. 
Следует отметить, что авторы выполняли замери времени исполнения 
только на процессорах семейства \Intel, 
следует ожидать, что замедление будет более существенным 
на процессорах с более слабой моделью памяти. 

\paragraph{Relaxed Memory Models: an Operational Approach}

В работе~\cite{Boudol-Petri:POPL09} был предложен 
операционный подход к заданию формальной семантики 
слабых моделей памяти (\RMMOA), 
основанный на абстрактной машине с общей памятью 
и иерархической структурой буферов для операций записи.
Более того, предложенная модель допускает
переупорядочивание находящихся в одном буфере
операций записи в различные локации памяти
(как в модели \PSO).
Авторы предоставили доказательство того,
что модель предоставляет свойство внешней свободы от гонок (\eDRF), 
но не проводили детального исследования 
корректности различных трансформаций кода. 

\subsection{Program Order Preserving}
\label{sec:catalog:porf}

В этом разделе описываются модели памяти, 
сохраняющие программный порядок и запрещающие 
спекулятивное исполнение с целью 
предотвратить появление значений из воздуха. 
В частности, рассматривается модель \RCMM
и несколько производных от неё, 
а также модель языка \OCaml и модель \JAM, 
являющаяся пересмотренной моделью \Java.  

\paragraph{RC11}

В работе~\cite{Lahav-al:PLDI17} была формализована
версия модели \CMM, сохраняющая порядок между 
операцией чтения и последующими операциями записи, 
а также исправляющая семантику последовательно согласованных обращений. 
Получившаяся модель стала известна под именем \RCMM. 

Авторы модели доказали корректность некоторых трансформаций 
(\see \cref{table:cmp-mms}).
Среди некорректных трансформаций, 
переупорядочивание типа чтение/запись запрещено 
по очевидным причинам (чтобы запретить спекулятивное исполнение), 
введение спекулятивной операции чтения запрещено 
из-за возгорающейся семантики для гонок на неатомарных переменных, 
наконец, удаление общих подвыражений запрещено, 
так как модель гарантирует когерентность 
на уровне ослабленных (и более строгих режимов) обращений к памяти
(отметим, что данная трансформация разрешена 
для неатомарных обращений, но, как уже упоминалось, 
гонки на неаторманых переменных влекут неопределенное поведение
в модели \RCMM) 

Для данной модели схема компиляции под процессоры архитектуры 
\Intel является оптимальной. Одна из возможных 
схем компиляций под процессоры семейств \ARM и \POWER
предполагает компиляций ослабленных (relaxed) операций чтения
как обычных инструкций чтения, за которыми следует 
ложная инструкция условного ветвления. 
В работе~\cite{Ou-Demsky:OOPSLA18} были изучены 
накладные расходы вызванные этой схемой компиляции
при компиляции под процессор семейства \ARMv{8}. 
Авторы модифицировали фреймворк \LLVM,
чтобы гарантировать модель памяти \RCMM, 
путем (1) модификации оптимизирующих проходов компилятора
и (2) модификации схемы компиляции. 
Было рассмотрено несколько возможных схем компиляции. 
Схема компиляции, описанная выше, продемонстрировала наилучшие результаты. 
Авторы измерили время работы нескольких тестов, 
реализующих различные многопоточные примитивы и структуры данных
(в частности, блокировки, стэки, очереди, деки, ассоциативные массивы
взятые из различных библиотек с открытым 
исходным кодом~\cite{CDSLib, FollyLib, JunctionLib}), 
и сообщили о замедлении на 0\% в среднем и 6.3\% максимум,
по сравнению с немодифицированной версией компилятора. 

\paragraph{RAR}

В работе~\cite{Doherty-al:PPoPP19} была предложена 
операционая версия для фрагмента модели \RCMM,
поддерживающая ослабленные (relaxed) и
освобождающие/захватывающие (release/acquire)
режимы обращения к памяти. 
На базе этой операционной семантики 
авторы разработали систему исчисления доказательств 
на основе инвариантов и верифицировали корректность
алгоритма блокировки. 

\paragraph{Operational RC11}

В работе~\cite{Dang-al:POPL19} была разработана 
ещё одна версия операционной семантики для модели \RCMM, 
которая была названа авторами \ORCMM.
Целью авторов была разработка программной логики 
(program logic) и доказательство её корректности 
относительно модели памяти \ORCMM.
Эта программная логика в свою очередь была использована
для доказательства корректности реализации нескольких 
примитивов синхронизации из стандартной библиотеки
языка \Rust~\cite{RustBook:19}.

\paragraph{Compositional Relaxed Concurrency}

В работе~\cite{Dodds-al:ESOP18} была предложена 
композициональная семантика (compositional relaxed concurrency, \CRC) 
для фрагмента модели памяти \CMM, 
который включает неатомарные обращения с возгорающейся семантикой для гонок, 
обращения к памяти с режимом доступа освобождения/захвата (release/acquire)
и последовательно согласованных барьеров. 
На основе этой семантики авторы разработали инструмент для 
автоматической верификации трансформаций кода
в рассматриваемом фрагменте модели памяти \CMM.
Так как ослабленные обращения не поддерживаются в этом фрагменте, 
авторы избежали проблем с возникновением значений из воздуха. 

\paragraph{OCaml Memory Model}

Авторы работы~\cite{Dolan-al:PLDI18} разработали новую модель памяти \OCMM
для языка \OCaml в рамках проекта \MOCaml.
Важное отличие модели \OCMM от других моделей подобных \CMM 
заключается в том, что она предоставляет более слабое свойство когерентности. 
Выбор более слабого типа когерентности был осознанным с целью 
разрешить трансформацию удаление общих подвыражений 
(\see подробности в \cref{sec:analysis:coh}).

Авторы также первыми предложили свойство локальной свободы от гонок (\lDRF),
которое является более сильной версией свойства обычнй свободы от гонок (\eDRF).
В то время как предусловием последнего является отсутствие 
гонок в всей программе, локальная свобода от гонок 
ограничивает эффект возникшей гонки на фрагмент программы, 
таким образом позволяя проводить композициональные рассуждения 
о поведении программ. 
Авторы выяснили, что свойство локальой свободы от гонок 
несовместимо с переупорядочиванием операций обращения к памяти типа чтение/запись.  
Этот факт вынудил авторов запретить эту трансформацию 
и адаптировать схему компиляции схожую со схемой для модели \RCMM. 

\paragraph{Java Access Modes}

В работе~\cite{Bender-Palsberg:OOPSLA19} была формализована 
новая версия модели памяти языка \Java версии 9~\cite{JDK9-VarHandle, JEP:193, JDK9-Modes}, 
которая была разработана, чтобы преодолеть трудности 
предыдущей версии модели~\cite{Manson-al:POPL05} 
(\see \ref{sec:catalog:jmm}).
Новая версия была вдохновлена моделью \RCMM.
В неё Была добавлена поддержка системы аннотаций на режимы доступа к переменым, 
названная ``Java Access Modes'' (отсюда и название модели --- \JAM),
аналогичная системе аннотаций в модели \CMM и её производных. 
Новая версия также адаптировла подход модели \RCMM к 
проблеме значений из воздуха. 
Было решено запретить переупорядочивание операций типа чтение/запись 
на уровне ``непрозрачных'', opaque, или более строгих обращений к памяти
(``непрозранчые'' обращения являются аналагом ослабленных, relaxed, 
обращений в модели \CPP).
Отметим, что модель памяти \JAM не решает проблему возникновения значений 
из воздуха на уровне неатомарных обращений. 

\subsection{Syntactic Dependencies Preserving}
\label{sec:catalog:deprf}

Далее мы обсуждаем модели памяти языков программирования, 
которые отслеживают синтаксические зависимости между операциями. 

\paragraph{Linux Kernel Memory Model}

Модель памяти \LKMM~\cite{Alglave-al:ASPLOS18} 
адаптировала идею по отслеживанию синтаксических зависимостей
между операциями с целью предотвратить появление значений из воздуха. 
Несмотря на то, что этот выбор ограничивает список поддерживаемых 
трансформаций, сохраняющих трассы программы, 
в контексте разработки ядра операционной системы 
он может быть оправдан по следующим соображениям. 
Во-первых, ядро системы Linux предназначено для работы 
на широком спектре архитектур с разнообразным 
набором моделей памяти. Чтобы упростить рассуждение о коде ядра
обоснованно выбрать модель памяти, сохраняющие синтаксические зависимости, 
так как модели этого класса очень близки концептуально к 
моделям памяти процессоров. 
Во-вторых, разработчики ядра и так уже используют 
различные техники для того, чтобы предотвратить
выполнение компилятором некоторых оптимизаций~%
\cite{Alglave-al:ASPLOS18, LK-MemBarriers, LK-RCU-Deref}.

Авторы модели эмпирический проверили корректность схем 
компиляции под процессоры семейств \Intel, \ARMv{7}, \ARMv{8} и \POWER. 
Они также формализовали механизм синхронизации 
read-copy-update (RCU)~\cite{McKenney-RCU2007}, 
широко применяемый в кодовой базе ядра Linux, 
и доказали корректность его реализации 
по отношению к предложенной модели памяти. 

\paragraph{Operational Happens-Before Model}

В попытке исправить модель памят языка \Java (\see \cref{sec:catalog:jmm}), 
авторы работы~\cite{Zhang-Feng:FCS16} предложили новую модель памяти \OHMM
(\emph{operational happens-before model}).
Абстрактная машина, реализующая их модель, 
состоит из глобального буфера событий, 
который позволяет переупорядочить события перед тем 
как они отправляются в глобальную память на основе истории сообщений, 
а также механизма воспроизведения исполнения (\emph{replay}), 
позволяющего симулировать спекулятивное исполение. 
Для того, чтобы предотвратить возникновение значений из воздуха, 
модель отслеживает синтаксические зависимости между 
событиями и запрещает переупорядочивание зависимых событий. 
Авторы доказали, что их модель обладает свойством внешней свободы от гонок (\eDRF)
и поддерживает некоторые трансформации над кодом 
(\see \cref{table:cmp-mms}).

\paragraph{Dependency Preserving Compiler}

В работе~\cite{Ou-Demsky:OOPSLA18} изучались накладные расходы
на время исполнения программы, возникающие из-за требования 
к компилятору сохранять синтаксические зависимости при выполнении оптимизаций. 
Авторы модифицировали фреймворк \LLVM, скомпилировали с его помощью 
набор тестов из набора \SPECCPU и запустили их на процессоре семейства \ARMv{8}.
В результате они наблюдали замедление времени работы программ 
на 3.1\% в среднем и 17.6\% максимум, по сравнению с немодифицированной версией \LLVM.  

\subsection{Semantic Dependencies Preserving}
\label{sec:catalog:sdeprf}

Далее мы обсуждаем модели памяти, 
которые предотвращают появление значений из воздуха 
путем отслеживания семантических зависимостей. 
В частности, этот класс моделей включает оригинальную 
версию модели языка \Java, обещащую семантику (Promising semantics), 
а также несколько моделей на основе \emph{структур событий}~\cite{Winskel:86}. 

\paragraph{Java Memory Model}
\label{sec:catalog:jmm}

Оригинальная версия модели памяти языка \Java (сокращенно \JMM)~\cite{Manson-al:POPL05}
является одной из первых работ по теме моделей памяти языков программирования.
Чтобы предотвратить появление значений из воздуха, 
авторы модели использовали понятие 
\emph{последовательности фиксации} (\emph{commit sequence}), 
то есть последовательности частичных графов сценариев исполнения программы. 
Было показано, что полученная модель обладает 
свойством внешней свободы от гонок~\cite{Huisman-Petri:CONCUR07}.
Тем не менее, оказалось что в этой модели
некоторые трансформации, подразумевавшиеся корректными, 
на самом деле не являются корректными~\cite{Sevcik-Aspinall:ECOOP08}.
(например, элиминация операций типа чтение/чтение, 
roach motel reordering, и другие, \see \cref{table:cmp-mms}). 

\paragraph{Generative operational semantics}

В работе~\cite{Jagadeesan-al:ESOP10} авторы предприняли попытку исправить модель \JMM,
и предложили порождающую операционную семантику с спекулятивным исполнением
(generative operational semantics, \GOS).
Для того чтобы избежать возникновение значений из воздуха, 
авторы наложили стратифицирующие ограничения на спекуляции. 
Было доказано, что полученная модель обладает свойством 
внешней свободы от гонок. 
Также авторы доказали корректность нескольких трансформаций
(переупорядочивание типа запись/запись, 
элиминация типа чтение/чтение, и roach motel reordering), 
но в целом изучение корректности трансформаций для данной модели не было систематическим. 

\paragraph{Promising Semantics}

В работах~\cite{Kang-al:POPL17, Lee-al:PLDI20} была предложена 
обещающая семантика (\emph{Promising semantics}, \PRM).
На сегодняшний день она представлет наиболее полную модель
в классе моделей, сохраняющих семантические зависимости. 
Ключевой частью этой модели является механизм обещаний и сертификации. 
Во время исполнения программы, абстракная машина, 
реализующая данную модель, может недетерминированно 
\emph{обещать} выполнить операцию записи,
затем она должна \emph{сертифицировать}, что данное обещание выполнимо. 
Механизм сертификации определен таким образом, чтобы 
предотвратить появление значений из воздуха. 
Авторы модели формально доказали, 
что обещающая семантика допускает множество 
локальных и глобальных трансформаций, 
за важным исключением трансформации слияния потоков 
(\see \cref{table:cmp-mms}).

В работах~\cite{Podkopaev-al:ECOOP17, Podkopaev-al:POPL19} 
была формально доказана корректность стандартных оптимальных 
схем компиляции под процессоры семейств \Intel, \ARMv{7}, \ARMv{8}, and \POWER.

Также, данная модель предоставляет полностью определенную 
семантику для неатомарных обращений 
(то есть гонки на неатомарных обращениях 
не рассматриваются как неопределенное поведение).
Отметим, однако, что неатомарные и ослабленные обращения 
к памяти имеют разную семантику. 
В частности, свойство когерентности гарантируютеся только 
для ослабленных обращений к памяти.
Такой дизайн модели позволяет поддержать 
трансформацию удаления общих подвыражений (\CSE)
на уровне неатомарных обращений. 

Одним из немногих ограничений обещающей семантики
является то, что она не поддерживает последователно согласованный 
режим доступа к переменным. 

\paragraph{Weakestmo}

В работах~\cite{Chakraborty-Vafeiadis:CGO17, Chakraborty-Vafeiadis:POPL19} 
была предложена модель памяти на основе структур событий (\WMO).
Авторы использовали способность структур событий кодировать
сразу несколько сценариев исполнения в одной структуре
для моделирования спекулятивного исполнения. 
Было продемонстрировано, что предложенная модель поддерживает 
оптимальные схемы компиляции~\cite{Moiseenko-al:ECOOP20}, 
некоторые трансформации кода (\see \cref{table:cmp-mms}), 
а также свойство внешней свободы от гонок. 
В отличие от обещающей семантики модель 
также поддерживает режим последовательно согласованных
обращений к памяти. 

\paragraph{A Concurrency Semantics for Relaxed Atomics}

Авторы работы~\cite{PichonPharabod-Sewell:POPL16} 
представили операционную модель памяти (\CSRA),
состоящую из подсистемы памяти, вдохновленной моделью памяти 
процессоров семейства \POWER, 
и подсистемой потоков, в которой каждый поток 
представлен как структура событий. 
На каждом шаге абстрактная машина либо 
добавляет новое событие, соответствующее операции обращения к памяти, 
в подсистему памяти, либо выполняет трансформацию 
над одной из структур событий. 
Авторы показали, что модель поддерживает оптимальные 
схемы компиляции под процессоры семейств \Intel и \POWER,
а также корректность некоторых трансформаций кода
(\see \cref{table:cmp-mms}). 
Однако позже было обнаружено, что 
модель не поддерживает оптимальные схемы компиляции
под процессоры семейств \ARMv{7} и \ARMv{8}~\cite{PichonPharabod:PhD18}.

\paragraph{Well-Justified Event Structures}

В работе~\cite{Jeffrey-Riely:LICS16} была предложена модель памяти (\WJES)
основанная на структурах событий и понятии 
\emph{обоснованности} событий (\emph{well-justification of events}), 
вдохновленного игровыми семантиками (\emph{game semantics}).
Понятие обоснованности событий необходимо для 
предотвращения появления значений из воздуха и 
доказательства выполнения свойства внешней свободы от гонок. 
Отметим, что авторы модели не изучали корректность трансформаций 
в их модели. Однако они продемонстрировали контрпримеры, 
показывающие что переупорядочивание операций типа чтение/чтение 
не является корректным. 
Этот факт также влечет то, что схемы компиляции 
под процессоры семейств \ARMv{7}, \ARMv{8}, и \POWER 
не могут быть оптимальными. 

\paragraph{Modular Relaxed Dependencies}

В работе~\cite{Paviotti-al:ESOP20} была построена 
денотационная семантика на основе стуктур событий (\MRD). 
Авторы данной модели использовали структуры событий 
для того, чтобы проследить семантические зависимости
между операциями доступа к памяти, 
которые, в свою очередь, используются 
чтобы предотвратить возникновение значений из воздуха. 
Авторы доказали, что модель обладает свойством внешней свободы от гонок,
также они доказали корректность оптимальных схем компиляции
и представили отношение уточнения (\emph{refinement relation}), 
которое может быть использовано для рассуждения о корректности трансформаций. 
Однако корректность каких-либо конкретных трансформаций кода не была изучена.

\subsection{Out of Thin-Air Values}

Finally, we discuss memory models admitting thin-air values. 

\paragraph{C11}

The most notable member of the OOTA class is the \CMM model~\cite{Batty-al:POPL11}.
The main purpose of the \CMM model was to adhere to the fundamental principle of \CPP, 
\ie to provide so-called zero-cost abstraction. 
In other words, the memory model was meant to provide 
efficient compilation mappings and support as many transformation as possible.
It was later revealed that the formal model partially fails to achive these goals.

Vafeiadis~\etal~\cite{Vafeiadis-al:POPL15} showed that several program transformation 
(load/store elimination, strengthening, roach motel reorderings, sequentialization) 
that deemed to be correct are actually unsound according to the formal model.
They proposed several local fixes to the model which 
partly repair soundness of transformations and improve 
its meta-theoretical properties. 

Batty~\etal~\cite{Batty-al:ESOP15} showed that 
the model also fails to provide the external \DRF guarantee, 
and that it is ultimately not possible to provide this guarantee
at all within the style of the \CMM formal semantics.
Only the internal \DRF can be proved for it. 

A lot of work~\cite{Batty-al:POPL11, Sarkar-al:PLDI12, Batty-al:POPL12, Batty-al:POPL16} 
was dedicated to prove soundness of optimal compilation mappings 
with respect to formal models of hardware, 
and there the results were mostly positive.
Besides that, Flur~\etal~\cite{Flur-al:POPL17} have extended 
the model to support mixed-size accesses.
Finally, Nienhuis~\etal~\cite{Nienhuis-al:OOPSLA16} presented 
a formal executable semantics in terms of an abstract machine, 
equivalent to the \CMM model. 

\paragraph{\JS Memory Model}

The \JSMM is based on the \CMM model. 
Like the latter, it also has the problem of thin-air values
and thus can only provide the internal \DRF guarantee. 
Contrary to the \CMM, the \JS model does not treat 
racy non-atomic accesses as undefined behavior. 

The main language primitive provided by the \JSMM
is \texttt{SharedArrayBuffer}, that is a linear mutable byte buffer.
Thus the model naturally supports mixed-size accesses.

\paragraph{A calculus for relaxed memory}

Crary and Sullivan~\cite{Crary-Sullivan:POPL15} proposed 
an alternative approach to the relaxed shared memory concurrency,
which they called \emph{Relaxed Memory Calculus} (\RMC).
Instead of deriving ordering constraints from annotations 
on memory accesses, they propose to directly specify 
the ordering between memory accesses in a source code. 
Their approach is highly generic and subsumes 
the traditional memory order annotations in the style of \CMM.
Their model is very weak and permits thin-air values. 
Yet the authors proved the internal \DRF theorem.

\paragraph{Relaxed Atomic + Ordering}

Saraswat~\etal~\cite{Saraswat-al:PPoPP07} presented the \RAO memory model
where relaxed behaviors are explained through transformations 
over a sequentially consistent execution.
Although the authors claim their model provides the external \DRF,
it also permits thin-air values. 
These two properties known to be incompatible~\cite{Batty-al:ESOP15}.
We suppose that the external \DRF can be achieved in their model 
only because of the fundamental restrictions on the input programming language 
(\eg the general conditional statements are not supported~\cite{PichonPharabod-Sewell:POPL16}). 

\paragraph{A theory of speculative computation}

Boudol and Petri~\cite{Boudol-Petri:ESOP10} proposed a general 
framework to study effects of speculative execution in
shared memory setting (\TSC). 
They have also noticed that the external \DRF does not 
hold in the presence of unrestricted speculations, 
yet the internal \DRF theorem still can be proven. 
