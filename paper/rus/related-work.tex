\section{Обзор литературы}
\label{sec:related}

Слабые модели памяти могут быть разделены на два класса:
для архитектур процессоров и для языков программирования.
Основная разница между ними заключается в том, что модели языков программирования
должны поддерживать широкий класс оптимизаций, выполняемых компиляторами. 

На сегодняшний день модели архитектур процессоров относительно хорошо изучены. 
Все основные архитектуры имеют формально определенные модели:
x86~\cite{Sewell-al:CACM10}, IBM~\POWER \cite{Alglave-DAMP09,Sarkar-al:PLDI11,Alglave-al:TOPLAS14}),
\ARM~\cite{Chong-ASPLOS08, Alglave-DAMP09,Pulte-al:POPL18,Flur-al:POPL16,Alglave-al:TOPLAS14})
и \RISC~\cite{Pulte-al:POPL18}.
Процессоры семейств x86 и \POWER обладают стабильными моделями, 
которые не претерпевали изменений в течении последних нескольких лет, 
в то время как модель памяти процессоров семейства \ARM 
существенно изменилась при переходе от \ARMv{7}~\cite{Alglave-al:TOPLAS14} 
к \ARMv{8}~\cite{Pulte-al:POPL18}
и была дополнена поддержкой новых инструкций для обращения к разделяемой памяти.
Архитектура \RISC\footnote{https://riscv.org/} была представлена в 2010 году 
и недавно к ней была адаптирована модель~\cite{Pulte-al:POPL18}, 
почти идентичная модели \ARMv{8}.

Все вышеупомянутые модели формализованы в \emph{декларативном} 
(или \emph{аксиоматическом}) стиле, 
ставшем стандартом для спецификации слабых моделей памяти и 
поддерживающим различные инструменты для 
тестирования и верификации моделей~\cite{Alglave-al:TOPLAS14}.
Модели некоторых языков программирования также используют декларативный стиль, например,
\CPP~\cite{Batty-al:POPL11}, \JS~\cite{Watt-al:PLDI2020}, Java~\cite{Manson-al:POPL05} и другие.
Тем не менее, декларативные модели не позволяют решить некоторые проблемы, 
характерные для моделей языков программирования, таких как C/C++, 
призванных обеспечить эффективную компиляцию в код целевой архитектуры и 
поддержку оптимизаций, которые потенциально могут удалять 
\emph{синтаксические зависимости} между инструкциями 
(например, распространение констант). 

Проблема заключается в том, что декларативные модели не способны 
отличить истинные \emph{семантические зависимости} между инструкциями от ложных.
Например, в примере ниже существует зависимость между 
инструкциями в левом потоке, в то время как зависимость между 
инструкциями в правом потоке является нет:
\[\begin{array}{l@{\qquad}|@{\qquad}l}
\readInst{}{r}{x} & \readInst{}{r}{x} \\
\writeInst{}{y}{r} & \readInst{}{y}{r * 0} \\
\end{array}\]
Для моделей памяти архитектур процессоров нет необходимости в таком различении, 
так как они сохраняют все синтаксические зависимости инструкций, 
в то время как оптимизирующий компилятор может, например, заменить выражение 
$r * 0$ на $0$ и таким образом удалить соотвествующую зависимость. 
Таким образом, необходимо либо различать истинные и ложные зависимости, 
либо полностью игнорировать информацию о зависимостях 
(текущая формализация модели \CPP использует второй подход).
Но если игнорировать информацию о зависимостях в комбинации с 
поддержкой \emph{буферизации операций чтения}, допустимых 
спецификацией процессоров \ARM и \POWER, 
то возникают так называемые 
\emph{значения из воздуха}~\cite{Boehm-Demsky:MSPC14}, 
нарушающие  базовые гарантии поведения программ
(эта проблема подробно обсуждается в~\cref{sec:background:oota}).

Для решения данной проблемы c сохранением
поддержки различных оптимизаций было предложено 
множество моделей, использующих различные подходы:
Java Memory Model (JMM)~\cite{Manson-al:POPL05}, Promising semantics~\cite{Kang-al:POPL17,Lee-al:PLDI20},
Weakestmo~\cite{Chakraborty-Vafeiadis:POPL19}, Modular Relaxed Dependencies (MRD)~\cite{Paviotti-al:ESOP20}.
Некоторые другие модели, например, \RCMM~\cite{Lahav-al:PLDI17} и модель памяти языка \OCaml~\cite{Dolan-al:PLDI18} избегают проблемы путем запрещения некоторых оптимизаций и предоставления больших гарантий~\cite{Ou-Demsky:OOPSLA18}.

Несмотря на то, что на сегодняшний день было предложено множество моделей языков программирования, которые
делают различные компромиссы и поддерживают различные возможности, 
насколько нам известно, не существует детального обзора этих моделей. 
Этот факт мотивировал нашу работу над данной статьей.

