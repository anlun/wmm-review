\section{Related Work}
\label{sec:related}

Слабые модели памяти могут быть разделены на два подкласса:
модели для архитектур процессоров и модели для языков программирования.
Основная разница между ними заключается в том, что от моделей языков программирования
ожидается поддержка широкого класса компиляторных оптимизаций и 
возможности компиляции под различные архитектуры. 

На сегодняшний день, модели архитектур процессоров относительно хорошо изучены. 
Все основные архитектуры имеют формально определенные модели:
x86~\cite{Sewell-al:CACM10}, IBM~\POWER \cite{Alglave-DAMP09,Sarkar-al:PLDI11,Alglave-al:TOPLAS14}),
\ARM~\cite{Chong-ASPLOS08, Alglave-DAMP09,Pulte-al:POPL18,Flur-al:POPL16,Alglave-al:TOPLAS14})
и \RISC~\cite{Pulte-al:POPL18}.
Процессоры семейств x86 и \POWER обладают стабильными моделями, 
которые не претерпевали изменений в течении последних нескольких лет, 
в то время как модель памяти процессоров семейства \ARM 
претерпела существенные изменения при переходе от \ARMv{7}~\cite{Alglave-al:TOPLAS14} 
к \ARMv{8}~\cite{Pulte-al:POPL18}
и была дополнена поддержкой новых инструкций для обращения к разделяемой памяти.
Архитектура \RISC\footnote{https://riscv.org/} была представлена в 2010 году 
и недавно адаптировала модель~\cite{Pulte-al:POPL18} 
почти идентичную модели \ARMv{8}.

Все вышеупомянутые модели формализованы в \emph{декларативных} 
(или \emph{аксиоматических}) стиле, 
ставшем стандартом для спецификации слабых моделей памяти и 
поддерживающим различные инструменты для 
тестирования и верификации моделей~\cite{Alglave-al:TOPLAS14}.
Модели некоторых языков программирования также используют декларативный стиль, например
\CPP~\cite{Batty-al:POPL11}, \JS~\cite{Watt-al:PLDI2020}, Java~\cite{Manson-al:POPL05} и другие.
Тем не менее декларативные модели не позволяют решить некоторые проблемы 
характерные для моделей языков программирования, таких как C/C++, 
призванных обеспечить эффективную компиляцию в код целевой архитектуры и 
поддерживать оптимизации, которые потенциально могут удалить 
\emph{синтаксические зависимости} между инструкциями 
(например, распространение констант). 

Проблема заключается в том, что декларативные модели не способны 
отличить истинные \emph{семантические зависимости} между инструкциями от ложных.
Например, в примере ниже существует истинная зависимость между 
инструкциями в левом потоке, в то время как зависимость между 
инструкциями в правом потоке является ложной:
\[\begin{array}{l@{\qquad}|@{\qquad}l}
\readInst{}{r}{x} & \readInst{}{r}{x} \\
\writeInst{}{y}{r} & \readInst{}{y}{r * 0} \\
\end{array}\]
Для моделей памяти архитектур процессоров в этом нет проблемы, 
так как они сохраняют все синтаксические зависимости, 
в то время как оптимизирующий компилятор может заменить выражение 
$r * 0$ на $0$ и таким образом удалить зависимость. 
Таким образом, необходимо либо различать истинные и ложные зависимости, 
либо полностью игнорировать информацию о зависимостях 
(текущая формализаци модели \CPP использует второй подход).
Но игнорирование информации о зависимостях в комбинации с 
поддержкой \emph{буферизаций чтений}, допустимых 
спецификацией процессоров \ARM and \POWER, 
приводит к возникновению так называемых 
\emph{значений из воздуха}~\cite{Boehm-Demsky:MSPC14}, 
нарушающих даже базовые гарании о поведении программ
(подробности этого обсуждаются в~\cref{sec:background:oota}).

Для решения проблемы значений из воздуха c сохранением
поддержки различных оптимизаций было предложено 
множество моделей использующих различные подходы:
Java Memory Model (JMM)~\cite{Manson-al:POPL05}, Promising semantics~\cite{Kang-al:POPL17,Lee-al:PLDI20},
Weakestmo~\cite{Chakraborty-Vafeiadis:POPL19}, Modular Relaxed Dependencies (MRD)~\cite{Paviotti-al:ESOP20}.
Некоторые другие модели, например, \RCMM~\cite{Lahav-al:PLDI17} и модель памяти языка \OCaml~\cite{Dolan-al:PLDI18},
решили избежать проблемы путем запрещения некоторых оптимизаций и предоставления больших гарантий~\cite{Ou-Demsky:OOPSLA18}.

Несмотря на то что было предложено множество моделей для языков программирования
делающих различные компромиссы и поддерживающиюх различные возможности, 
насколько нам известно не существует детального обзора этих моделей. 
Этот факт мотивировал нашу работу над данной статьей.
