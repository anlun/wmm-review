\section{Сравнение}
\label{sec:comparison}

Мы провели сравнение моделей памяти, 
отобранных с помощью процедуры описанной в \cref{sec:methodology},
по критериям, представленным в \cref{sec:background}. 
В этом разделе представлены результаты этого сравнения.

Сравнение моделей памяти было 
осложнено тем фактом, что рассмотренные 
статьи, зачастую, используют различную терминологию, 
предоставляют неполную информацию о моделях памяти, а в некоторых случая статьи  
 противоречат друг другу. 
Мы подошли к решению этих трудностей следующим образом. 
Во-первых, для обозначения свойств моделей памяти
мы использовали единую терминологию,
описанную нами в \cref{sec:background}.
Во-вторых, мы дополняли информацию о каждой модели 
из разных источников. Если после этого 
наличие или отсутствие определенного свойства у модели 
все ещё оставалось неясным, мы явно помечали этот факт. 

Мы идентифицировали шесть классов моделей памяти:
последовательно согласованные (sequentially consistent); 
модели с линейным/частичным порядком на операциях записи
(total or partial store order);
модели, сохраняющие программный порядок
(program order preserving models); 
модели, сохраняющие синтаксические зависимости 
(syntactic dependency preserving);
модели, сохраняющие семантические зависимости
(semantic dependency preserving);
модели допускающие значения из воздуха
(out of thin-air). 
Модели из одного класса имеют схожие схемы компиляции, 
множество корректных трансформаций и предоставляемые гарантии. 
Сначала мы представляем результат сравнения различных классов 
(\cref{table:cmp-cls}),
а затем --- сравнение отдельных моделей 
(~\cref{table:cmp-mms}).

\input{../common/smalltable.tex}

В \cref{table:cmp-cls} и \cref{table:cmp-mms} 
мы упорядочиваем модели по степени их ослабленности. 
Более строгие модели расположены в верхних строках, 
а более слабые --- в нижних.  

Колонки обоих таблиц соответствуют свойствам моделей памяти.
Для краткости мы выбрали бинарную классификацию свойств,
т.е. считаем, что модель либо удовлетворяет данному свойству, либо нет. 
Мы также разделили все свойства на несколько групп. 

Первая группа свойств посвящена оптимальности схем компиляции 
для различных семейств процессоров. 
Мы классифицируем схему компиляции как оптимальную 
или неоптимальную следующим образом. 
Мы выбираем наиболее слабый режим доступа, 
поддерживаемый моделью памяти, и рассматриваем 
схему компиляции для обращений к памяти, аннотированных данным режимом. 
Для моделей, которые трактуют гонки на неатомарных переменных 
как неопределенное поведение, 
мы рассматриваем наиболее слабый режим доступа к атомарным переменным. 
Дело в том, что семантика с неопределенным поведением 
для программ с гонками тривиальным образом допускает 
оптимальную схему компиляции (\see~\cref{sec:background:ub}).
Мы считаем схему компиляции \emph{оптимальной}, 
если обращения к памяти, аннотированные выбранным режимом доступа, 
могут быть скомпилированы в обычные инструкции чтения 
и записи целевой архитектуры 
(т.е. без использования барьеров памяти или какого-либо другого дополнительного кода).

Вторая группа свойств посвящена корректности различных трансформаций. 
Здесь классификация также бинарная: конкретная трансформация 
либо является корректной в данной модели, либо нет. 
Мы вновь не рассматриваем все возможные комбинации 
трансформаций и режимов доступа. 
Вместо этого мы останавливаемся только на наиболее слабом режиме доступа с  полностью определенной семантикой (т.е. без неопределенного поведения).
Также  мы разделяем трансформации на локальные и глобальные. 

Третья группа свойств соответствует предоставляемым гарантиям
о поведении программ. В частности, для каждой модели
мы указываем, предоставляет ли она свойство 
внешней свободы от гонок \eDRF (\see~\cref{sec:background:drf}),
свойство когерентности (\see~\cref{sec:background:coh}),
 трактует ли она гонки на неатомарных переменных как неопределенное поведение (см.~\cref{sec:background:ub}),
используется ли последовательное исполнение инструкций (\emph{in-order execution}) 
или применяет спекулятивное исполнение (\emph{speculative execution}),
а также допускает ли данная модель значения из воздуха (см.~\cref{sec:background:oota}).

В \cref{table:cmp-cls} каждая строка соответствует целому классу моделей. 
Клетка помечается символом ``\cmark\xspace'' если большинство моделей 
данного класса обладают соответствующим свойством. 
Если рассматриваемым свойством обладает только некоторое количество моделей данного класса, 
не составляющих большинство, то клетка помечается символом ``\wmark\xspace''.
Наконец, если ни одна из моделей данного класса не обладает данным свойством, 
тогда клетка помечается символом ``\xmark\xspace''.
При подсчете большинства 
мы опускаем те модели данного класса, про которые неизвестно, обладают 
они данным свойством или нет. 
Также, если какое-то свойство вообще не изучалось 
в контексте определенного класса моделей, 
% (т.е. в~\cref{table:cmp-mms} все клетки моделей этого класса закрашены серым),
мы также помечаем клетку символом ``\xmark''. 
Таким образом, в \cref{table:cmp-cls} символы ``\cmark\xspace'' и ``\wmark\xspace'' 
обозначают положительную информацию, а символ ``\xmark\xspace'' обозначает 
как негативную информацию, так и отсутствие информации. 

В \cref{table:cmp-mms} каждая строка соответствует 
конкретной модели памяти, обозначаемой аббревиатурой, 
а каждая клетка описывает наличие или отсутствие определенного свойства этой модели. 
Мы помечаем клетку символом ``\cmark\xspace'', если 
рассматриваемая модель обладает данным свойством 
и символом ``\xmark\xspace'' в противном случае. 
Если нам не удалось получить информацию о данном свойстве рассматриваемой модели, 
то соответствующая клетка заливается серым цветом~%
{\protect\tikz \protect\draw[fill=colorQmark] (0,0) rectangle ++(0.35,0.35);}. 

Помимо \cref{table:cmp-cls,table:cmp-mms}, 
которые описывают свойства моделей, мы также 
представляем \cref{table:features}, содержащую 
список примитивов, поддерживаемых каждой моделью. 
Каждая строка данной таблицы соответствует отдельной модели памяти.
Колонки соответствуют поддерживаемым примитивам. 
В частности, мы указываем, какие режимы обращений к переменным модель поддерживает:
неатомарные~(NA), ослабленные~(RLX), захвата/освобождения~(RA), 
последовательно согласованные~(SC); 
какие типы барьеров поддержаны:
захвата/освобождения~(RA) и последовательно согласованные~(F-SC);
поддерживаются ли атомарные операции чтения-модификации-записи~(RMW),
поддерживаются ли явно операции блокировки~(LK),
и поддерживаются ли смешанные обращения~(MIX).   


\input{../common/fulltable.tex}

\input{../common/features-table.tex}
