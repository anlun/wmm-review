\section{Сравнение}
\label{sec:comparison}

Мы провели сравнение моделей памяти, 
отобранных с помощью процедуры описанной в \cref{sec:methodology},
по критериям, представленным в \cref{sec:background}. 
Проведение сравнительного анализа моделей было 
осложнено тем фактом, что рассматриваемые 
научные статьи зачастую используют различную терминологию, 
предоставляют неполную информацию о моделях памяти 
и иногда они даже противоречат друг другу. 
Мы подошли к решению этих трудностей следующим образом. 
Во-первых, для обозначения свойств моделей памяти
мы использовали единообразную терминологию,
представленную в \cref{sec:background}.
Во-вторых, мы дополняли информацию о каждой модели 
из разных источников. Если после этого 
наличие или отсутствие определенного свойства у модели 
все ещё оставалось неясным, мы явно помечали это. 

На основе нашего сравнения мы идентифицировали 6 классов моделей памяти:
последовательно согласованные (sequentially consistent); 
модели с линейным или частичным порядком на операциях записи
(total or partial store order);
модели, сохраняющие программный порядок
(program order preserving models); 
модели, сохраняющие синтаксические зависимости 
(syntactic dependency preserving);
модели, сохраняющие семантические зависимости
(semantic dependency preserving);
модели допускающие значения из воздуха
(out of thin-air). 
Модели из одного класса имеют схожие схемы компиляции, 
множество корректных трансформаций и предоставляемые гарантии. 
Сначала мы представляем результат сравнения различных классов, 
(\see~\cref{table:cmp-cls} и~\cref{sec:analysis})
а уже затем более детальное сравнение моделей в отдельности
(\see~\cref{table:cmp-mms} и~\cref{sec:catalog}).
Таким образом мы имеем возможность сначала обсудить общие 
принципы моделей памяти языков программирования, 
а уже затем погрузиться в детали каждой модели в отдельности. 

\input{../common/smalltable.tex}

В \cref{table:cmp-cls} и \cref{table:cmp-mms} 
мы упорядочиваем модели по степени их ослабленности. 
Более строгие модели расположены в верхних строках, 
а более слабые в нижних.  

Колонки двух таблиц соответствуют свойствам моделей памяти.
Для краткости мы выбрали бинарную классификацию всех свойств,
\ie считается что модель либо удовлетворяет свойству, либо нет. 
Мы также разделили все свойства на несколько групп. 

Первая группа посвящена оптимальности схем компиляции 
под различные семейства архитектур процессоров. 
Мы классифицируем схему компиляции как оптимальную 
или неоптимальную следующим образом. 
Мы выбираем наиболее слабый режим доступа 
поддерживаемый моделью памяти и рассматриваем 
схему компиляции для обращений к памяти аннотированных данным режимом. 
Для моделей, которые присваивают неопределенное поведение 
программам с гонками на неатомарных переменных, 
мы рассматриваем наиболее слабый режим доступа к атомарным переменным. 
Дело в том, что семантика с неопределенным поведением 
для программ с гонками тривиальным образом допускает 
оптимальную схему компиляции (\see~\cref{sec:background:ub}).
Мы считаем схему компиляции \emph{оптимальной} 
если обращения к памяти, аннотированные выбранным режимом доступа, 
могут быть скомпилированы в обычные инструкции чтения 
и записи целевой архитектуры 
(\ie без использования барьеров памяти или какого-либо другого дополнительного кода).

Вторая группа посвящена корректности различных трансформаций. 
Здесь классификация также бинарная: конкретная трансформация 
либо является корректной в данной модели, либо нет. 
Мы вновь не рассматриваем все возможные комбинации 
трансформаций и режимов доступа. 
Вместо этого мы рассматриваем только наиболее слабый режим доступа
имеющий полностью определенную семантику (\ie без неопределенного поведения).
Также как и в~\cref{sec:background:trans} мы дополнительно 
подразделяем трансформации на локальные и глобальные. 

Третья группа соответствует предоставляемым гарантиям
о поведении программ. В частности, для каждой модели
мы указываем предоставляет ли она свойство 
внешней свободы от гонок \eDRF (\see~\cref{sec:background:drf}),
свойство когерентности (\see~\cref{sec:background:coh}),
присваивает ли она неопределенное поведение гонкам 
на неатомарных переменных (\see~\cref{sec:background:ub}),
используется ли последовательное исполнение инструкций (\emph{in-order execution}), 
или модель применяет спекулятивное исполнение (\emph{speculative execution}),
а также допускаются ли значения из воздуха (\see~\cref{sec:background:oota}).

В \cref{table:cmp-mms} каждая строка соответствует 
конкретной модели памяти, обозначаемой аббревиатурой, 
а каждая клетка описывает наличие или отсутствие определенного свойства. 
Мы помечаем клетку символом \cmark\xspace если 
соответствующая модель обладает данным свойством 
и символом \xmark\xspace в противном случае. 
Если свойство не было изучено в научных статьях, 
то соответствующая клетка заливается серым цветом~%
{\protect\tikz \protect\draw[fill=colorQmark] (0,0) rectangle ++(0.35,0.35);}. 

В \cref{table:cmp-mms} каждая строка соответствует целому классу моделей. 
Клетка помечается символом \cmark\xspace если большинство моделей 
данного класса обладают соответствующим свойством. 
Если свойством обладает только некоторое количество моделей, 
не составляющих большинство, то клетка помечается символом \wmark\xspace.
Наконец, если ни одна из моделей данного класса не обладает свойством, 
тогда клетка помечается символом \xmark\xspace.
Обратите внимание, что при подсчете большинства 
мы опускаем модели про которые неизвестно обладают 
они свойством или нет. 
Также, если какое-то свойство вообще не изучалось 
в контексте определенного класса моделей 
(\ie, в~\cref{table:cmp-mms} все клетки моделей этого класса закрашены серым)
мы также помечаем клетку символом \xmark. 
Таким образом, в \cref{table:cmp-cls} символы \cmark\xspace и \wmark\xspace 
обозначают положительную информацию, а символ \xmark\xspace обозначает 
как негативную информацию, так и отсутствие информации. 

Помимо \cref{table:cmp-cls,table:cmp-mms}, 
которые описывают свойства моделей, мы также 
представляем \cref{table:features}, содержащую 
список примитивов, поддерживаемых каждой моделью. 
Каждая строка данной таблицы соответствует отдельной модели памяти.
Колонки соответствуют поддерживаемым примитивам. 
В частности, мы указываем какие режимы обращений поддержаны:
неатомарные~(NA), ослабленные~(RLX), захвата/освобождения~(RA), 
последовательно согласованные~(SC); 
какие типы барьеров поддержаны:
захвата/освобождения~(RA) и последовательно согласованные~(F-SC);
поддерживаются ли атомарные операции чтения-модификации-записи~(RMW),
поддерживаются ли явно операции блокировки~(LK),
и поддерживаются ли смешанные обращения~(MIX).   

% Finally, the last group enumerates the list of memory access modes 
% and fences supported by the model, as well as whether the model 
% supports read-modify-write operations, locks, and mixed-size accesses.

\input{../common/fulltable.tex}

\input{../common/features-table.tex}
