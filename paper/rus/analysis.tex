\section{Анализ}
\label{sec:analysis}

% We partitioned all models into six primary classes: 
% sequentially consistent models, models with total or partial order on stores, 
% program order preserving models, syntactic dependency preserving models, 
% semantic dependency preserving models, and model with out of thin-air values.

В этой главе мы обсуждаем введеные класы моделей памяти.
На основе данных из таблицы 
мы выводим взаимосвязи между оптимальностью схемы компиляции,
корректностью трансформаций и предоставляемыми гарантиями. 
В частности, мы демонстрируем как поддержка 
некоторых гарантий конфликтует с некоторыми трансформациями 
и как она влияет на оптимальность схемы компиляции. 

Мы начинаем с рассмотрения класса 
последовательно согласованных моделей~\cref{sec:analysis:seqcst}.
Затем мы переходим к моделям с линейным или 
частичным порядком на записях~\cref{sec:analysis:tso}.
После этого, мы рассматриваем класс наиболее слабых моделей 
допускающих значения из воздуха~\cref{sec:analysis:oota}.
Далее мы переходим к обсуждению различных подходов 
к решению проблемы значений из воздуха и рассмариваем модели, 
сохраняющие программный порядок~\cref{sec:analysis:porf},
синтаксические зависимости~\cref{sec:analysis:deprf} и
семантические зависимости~\cref{sec:analysis:sdeprf}.
 
В \cref{sec:analysis:other} мы отдельно обсуждаем некоторые 
конкретные свойства моделей, в частности, когерентность и возгорающуюся семантику. 
Факт наличия или отсутствия этих свойств ортогонален
разбиению на вышеупомянутые классы. 
Тем не менее наличие этих свойств у модели также влияет 
на корректность определенных трансформаций.

\subsection{Последовательная Согласованность}
\label{sec:analysis:seqcst}

Модель последовательной согласованности (\SC)
является наиболее интуитивной моделью конкурентности.
В рамках этой модели состояние памяти может быть 
представлено как просто отображение из 
адресов переменных в хранящиеся значения. 
Тогда каждый допустимый сценарий поведения программы 
может быть получен в результате поочередного последовательного
исполнения инструкций потоков. 

Многие распростаненные трансформации оказываются 
некорректными в модели \SC, включая 
все типы переупорядочивания инструкций, 
а также удаление общих подвыражений~\cite{Marino-al:PLDI11, Sevcik-Aspinall:ECOOP08}.
Тот факт что переупорядочивание инструкций запрещено 
делает эту модель очень дорогостоящей при реализации
на современных процессорах, так как даже 
относительно строгая модель памяти \Intel
допускает переупорядочивания типа запись/чтение. 
Таким образом, чтобы гарантировать последовательную согласованность, 
компилятор вынужден вставлять в код тяжеловесные 
барьеры памяти между инструкциями записи и чтения,
что делает схему компиляции далеко не оптимальной. 

Однако в терминах предоставляемых программисту гарантий 
модель \SC является весьма привлекательной. 
В частности, тривиальным образом гарантируется свойства \DRF и когерентности, 
так как модель присваивает программе только 
последовательно согласованные сценарии поведения. 

Концептуальная простота и привлекательность модели \SC 
вдохновила многих исследователей на попытки 
адаптации этой модели и смягчения накладываемых 
штрафов на время исполнения программы. 
Общей идеей данных работ была попытка 
отделения локальных (доступных только одному потоку) 
и разделяемых переменных.
Обращения к локальным переменным могут быть скомпилированы 
без добавления барьеров памяти, также к ним 
применим широкий спектр оптимизация корректных 
для случая однопоточных программ. 
Чтобы безопасным образом классифицировать 
локальные и разлеляемы переменные исследователи 
использовали системы типов~\cite{Vollmer-al:PPoPP17},
статический~\cite{Singh-al:ISCA12} или динамический анализ~\cite{Liu-al:PLDI19}, 
поддержку на аппаратном уровне~\cite{Singh-al:ISCA12, Marino-al:PLDI10}, 
или различные комбинации вышеупомянутых методов.  

Несмотря на эти усилия, модель \SC все равно имеет существенные накладные расходы. 
Например, при компиляции на процессоры семейства \ARMv{8}
замедление времени работы программ может достигать 70\%~\cite{Liu-al:PLDI19} 
(\see подробности в \cref{sec:catalog:sc}).
Более того, хотя вышеупомянутые техники обычно уменьшают 
накладные расходы на локальные обращения 
(которые, зачастую, чаще встречаются в программах),
они оказывают меньшее влияние на специфичные приложения, 
которые активно использую конкурентность, 
например, такие как неблокирующие структуры данных.
Наконец, требуется значительное количество усилий 
и технической работы, чтобы модифицировать 
современные компиляторы для поддержки модели \SC~\cite{Marino-al:PLDI11, Liu-al:PLDI19}.

\subsection{Линейный и частичный порядок на записях}
\label{sec:analysis:tso}

Следующий рассматриваемый класс моделей был вдохновлен моделями с 
\emph{линейным порядком на записях} (\emph{total store order}, \TSO)
и \emph{частичным порядком на записях} (\emph{partial store order}, \PSO)~\cite{Sparc:94}.
Модели \TSO и \PSO являются моделями семейств процессоров \Intel~\cite{Sewell-al:CACM10} 
и \SPARC~\cite{Sparc:94} соответственно. 
В этих моделям потоки оснащены \emph{буферами записей}.
Все операции записи сперва попадают в эти буферы, а уже 
затем переносятся в основную память. 

Для моделей этого класса схема компиляции под архитектуру \Intel 
является оптимальной, так как \Intel предоставляет модель \TSO.  
Однако при компиляции под архитектуры с более слабой моделью памяти, 
например~\POWER, необходимо использовать практический такое же 
количество барьеров, как и при компиляции из модели~\SC~\cite{Lustig-al:AISCA15}.

Модели этого класса допускают большее количество трансформаций кода чем \SC.
Использование буферов записи позволяет выполнять переупорядочивание 
типа запись/чтение в случае~\TSO, и также 
переупорядочивание типа запись/запись в случае~\PSO.

Хотя модели \TSO и \PSO слабее модели \SC, 
тем не менее они все ещё предоставляют довольно сильные гарантии, 
в частности, свойсва \DRF и когерентности.    

Таким образом, модели этого класса не имеют 
значительных преимуществ перед моделью \SC, 
и при этом влекут соизмеримые накладные расходы 
при компиляции под архитектуры c более слабой моделью памяти чем у \Intel. 
Следовательно, выбор этих моделей в качестве моделей для 
языка программирования оправдан только если предполагается 
поддержка компиляции только под процессоры архитектуры \Intel. 

\subsection{Значения из воздуха}
\label{sec:analysis:oota}

Далле мы переместимся на другой конец спектра моделей памяти
и рассмотрим класс, в который входят наиболее слабые модели
из рассматриваемых нами. 
Эти модели предоставляют оптимальные схемы компиляции и 
допускают практический любые разумные трансформации программ, 
но достигают этого ценой введения значений из воздуха 
(\cref{sec:background:oota}).

Рассмотрим вновь пример программы буфферизации чтения:

\begin{minipage}{0.43\linewidth}
\begin{equation*}
\small
\inarrII{
  \readInst{}{r_1}{x}     \\
  \writeInst{}{y}{1}      \\
}{
  \readInst{}{r_2}{y}     \\
  \writeInst{}{x}{r_2}    \\
}
\tag{LB}\label{ex:lbA}
\end{equation*}
\end{minipage}\hfill%
\begin{minipage}{0.09\linewidth}
\Large~\\ $\leadsto$
\end{minipage}\hfill%
\begin{minipage}{0.43\linewidth}
\begin{equation*}
\inarrII{
  \writeInst{}{y}{1}      \\
  \readInst{}{r_1}{x}     \\
}{
  \readInst{}{r_2}{y}     \\
  \writeInst{}{x}{r_2}    \\
}
\tag{LBtr}\label{ex:lbB}
\end{equation*}
\end{minipage}

Версия программы справа \ref{ex:lbB} может быть 
получена из программы слева \ref{ex:lbA} 
путем применения переупорядочивания инструкций типа чтение/запись. 
Результат ${[r_1=1, r_2=1]}$ допустим для программы \ref{ex:lbB}.
Тогда модель памяти, в которой переупорядочивание типа чтение/запись
является корректной трансформацией, также должна 
допускать этот результат для программы \ref{ex:lbA}.
Как было продемонстрировано в \cref{sec:background:oota}, 
для того чтобы получить такой результат, 
необходимо прибегнуть к спекулятивному исполнению. 

Мы также обсуждали, что не ограниченное 
спекулятивное исполнение может привести к появлению 
так называемых значений из воздуха, 
которые нарушают фундаментальные гарантии 
о поведении программ~%
\cite{Boehm-Demsky:MSPC14, Batty-al:ESOP15}, 
в частности, гарантии типобезопасности (type-safety)
и композициональности.  
Также не выполняется и гарантия внешней свободы от гонок (\eDRF).
Чтобы убедиться в этом, рассмотрим ещё один пример:

\begin{equation*}
\inarrII{
  \readInst{}{r_1}{x}      \\
  \kw{if} {(r_1)} ~\{      \\
  \quad\writeInst{}{y}{1}  \\
  \}
}{
  \readInst{}{r_2}{x}      \\
  \kw{if} {(r_2)} ~\{      \\
  \quad\writeInst{}{x}{1}  \\
  \}
}
\tag{LB+ctrl}\label{ex:lb+ctrl}
\end{equation*}

Для модель памяти, допускающей значения из воздуха, 
результат ${[r_1=1, r_2=1]}$ также является допустимым
(обоснование этого результата такое же как и для 
примера \ref{ex:lb+data} из \cref{sec:background:oota}).
Однако этот результат не только совершенно неинтуитивен, 
но и противоречит гарантии внешней свободы от гонок. 
Действительно, в модели \SC единственный допустимый 
сценарий поведения этой программы ведет к результату $[r_1=0, r_2=0]$ 
и не содержит никаких гонок, следовательно 
в модели, предоставляющей гарантию \eDRF, 
эта программа также должа иметь только этот единственный 
сценарий поведения. 

Контр-интуитивное поведение моделей 
допускающих значения из воздуха, 
а также тот факт что они нарушают множество 
важных гарантий о поведении программ, 
привело к консенсусу в исследовательском сообществе о том, 
что эти модели не подходят на роль моделей памяти 
для языков программирования~\cite{Boehm-Demsky:MSPC14, Batty-al:ESOP15}.  
Множество усилий было приложено для того, 
чтобы запретить проблематичные значения из воздуха, 
но в то же время сохранить оптимальность схем 
компиляции и корректность как можно большего количества трансформаций. 
В оставшейся части этой главы мы опишем различные 
способы борьбы с проблемой значений из воздуха. 

\subsection{Сохранение программного порядка}
\label{sec:analysis:porf}

Наиболее простой способ запретить значения из воздуха 
был предложен в работе~\cite{Boehm-Demsky:MSPC14}.
Основная идея --- полностью запретить спекулятивное исполнение, 
что может быть достигнуто путем запрета переупорядочивания 
инструкций типа чтение/запись. 
Это решение позволяет не только восстановить 
свойство внешней свободы от гонок (\eDRF) 
и другие гарантии~\cite{Lahav-al:PLDI17}, 
но также ведет и к более простой модели. 
Абстрактная машина, реализующая данную модель, 
не нуждается в использовании спекулятивного исполнения
и может выполнять инструкции потоков согласно их
\emph{программному порядку}, \ie в том порядке, в котором они указаны. 
Память такой машины может быть организована 
как монотонно растущая история сообщений, 
где каждый поток имеет свой взгляд на 
фронт данной истории~\cite{Dolan-al:PLDI18, Doherty-al:PPoPP19}. 

Данный подход к решению проблемы значений из воздуха 
был формализован в работе~\cite{Lahav-al:PLDI17}.
Авторы работы показали, что многие трансформации над 
кодом программ, за исключением переупорядочивания 
инструкций типа чтение/запись, остаются корректными в рамках 
моделей данного класса (\see~\cref{table:cmp-cls})

Схема компиляции в процессоры семейства \Intel
является оптимальной, так как модель памяти данной 
архитектуры гарантирует сохранение порядка 
между чтениями и последующими записями. 
Однако более архитектуры с более слабыми моделями (\ARM, \POWER)
не гарантируют сохранения этого порядка, 
и таким образом требуют принятия дополнительных мер при компиляции кода. 
В~\cite{Boehm-Demsky:MSPC14} было предложено компилировать 
ослабленные ($\rlx$) чтения как обычные чтения, 
за которыми следует ложная инструкция условного прыжка 
(conditional jump), которая добавляет зависимость 
между чтением и последующими записями. 
Гарантируется, что процессоры семейств \ARM and \POWER 
сохранят такую зависимость, и, таким образом, 
сохранят и порядок между чтением и последующими записями. 
В работе~\cite{Ou-Demsky:OOPSLA18} изучались 
накладные расходы этой схемы компиляции, 
при её применении только к \textbf{ослабленным ($\rlx$) атомарным обращениям}.
При компиляции под процессоры семейства \ARMv{8} 
замедление времени работы составило 0\% в среднем и 6.3\% максимум 
на наборе тестов, реализующих различные конкурентные 
структуры данных, например, блокировки, стеки, очереди, 
деки, ассоциативные массивы, \etc
(подробности приведены в \ref{sec:catalog:porf}).
Заметим, что следует ожидать более существенного замедления
при применении данной схемы компиляции для 
сохранения порядка также между неатомарными обращениями. 

\subsection{Сохранение синтаксических зависимостей}
\label{sec:analysis:deprf}

Альтернативное простое решение проблемы значений из воздуха 
заключается в сохранении \emph{синтаксических зависимостей}~%
\cite{Boehm-Demsky:MSPC14, Alglave-al:ASPLOS18}.
В рамках этого подхода переупорядочивание типа чтение/запись 
разрешено, если переставляемые инструкции являются независимыми. 
Но переупорядочивание запрещено, если запись зависит 
от значения, прочитанного чтением, 
(в этом случае мы говорим что существует зависимость по данным, \emph{data dependency})
или если это значение было использовано при вычислении адреса записи 
(зависимость по адресу (\emph{address dependency}), 
или если путь исполнения программы, ведущей к записи, 
зависит от прочитанного значения 
(зависимость по управлению, (\emph{control dependency}).
Например, в программе \ref{ex:lb+data} 
сущесвтует зависимость по данным, так как 
инструкция $\writeInst{}{y}{r_1}$ записывает 
значение, прочитанное инструкцией $\readInst{}{x}{r_1}$. 

Заметим что эти зависимости вычисляются следую 
синтаксису программы (отсюда и название), 
в противоположность \emph{семантическим зависимостям}. 
Например, в модифицированной версии 
программы \ref{ex:lb+data}, показанной ниже, 
запись в переменную \texttt{y} в левом потоке все ещё 
имеет синтаксическую зависимость от предыдущего чтения. 

\begin{equation*}
\inarrII{
  \readInst{}{r_1}{x}           \\
  \writeInst{}{y}{1 + 0 * r_1}  \\
}{
  \readInst{}{r_2}{y}      \\
  \writeInst{}{x}{r_2}     \\
}
\tag{LB+fakedata}\label{ex:lb+fakedata}
\end{equation*}

В этом примере синтаксическая зависимость может быть удалена
при применении оптимизации распространения констант ---
подвыражение $1 + 0 * r_1$ может быть преобразовано в значение~$1$.
Однако если модель памяти гарантирует сохранение синтаксических зависимостей,
компилятору запрещено применять эту оптимизацию, 
так как после удаления зависимости ничто не мешает 
переставить запись до предшествующего чтения. 
Даже если сам компилятор не выполнит такое переупорядочивание, 
его может выполнить процессор во время исполнения 
скомпилированной программы. 

На этом примере можно видеть главный недостаток моделей, 
сохраняющих синтаксические зависимости --- 
различные оптимизации, сохраняющие трассы
(\eg распространение констант), некорректны в этих моделях. 
Распространение констант является одной из 
классических оптимизаций, и тот факт, 
что оно некорректно препятствует принятию 
моделей этого класса. 
Заметим, что модели архитекту процессоров 
используют схожий подход и тоже 
сохраняют синтаксические зависимости 
между обращениями к разделяемой памяти%
~\cite{Sarkar-al:PLDI11, Alglave-al:TOPLAS14, Pulte-al:POPL18}.
Однако в этом случае это не является проблемой, 
так как процессоры во время исполнения программы 
не выполняют такие сложные оптимизации, 
как распространение констант.

В работе~\cite{Ou-Demsky:OOPSLA18} изучалось 
замедление времени работы программ, накладываемое моделью памяти, 
сохраняющией синтаксические зависимости. 
Авторы модифицировали оптимизирующие проходы компилятора, 
чтобы они сохраняли зависиомости между 
\textbf{неатомарными и ослабленными ($\rlx$) атомарными} обращениями. 
Затем они измерили время работы программ из тестового набора \SPECCPU,
скомпилированных модифицированной версией компилятора \LLVM 
под процессор семейства \ARMv{8}, и сообщили 
об умеренном замедлении на 3.1\% в среднем и 17.6\% максимум
(подробности приведены в \ref{sec:catalog:deprf}). 

\subsection{Сохранение семантических зависимостей}
\label{sec:analysis:sdeprf}

Последний рассматриваемый нами подход к проблеме значений из воздуха 
заключается в построении понятия \emph{семантических зависимостей}, 
которые могли бы точно характеризовать какие пары чтения/записи
являеются независимыми, и отфильтровали бы ложные зависимости, 
как в примере \ref{ex:lb+fakedata}.
Практическая ценность данного подхода заключается в том, что 
он не требует модификаций существующих компиляторов 
и процессоров и не накладывает дополнительных 
расходов на время исполнения скомпилированных программ. 
Конечной целью является предоставление оптимальных схем компиляции, 
сохранение корректности большинства существующих трансформаций кода, 
и в то же время поддержка важных гарантий, 
таких как внешняя свобода от гонок (\eDRF).

Оказывается, что эта задача является весьма трудной 
и на сегодняшний день все ещё не существует консенсуса 
по способу её решения. 
Чтобы дать удовлетворительное определение семантических зависимостей 
исследователи вынуждены были обратиться к концептуально 
сложным моделям памяти~\cite{Jagadeesan-al:ESOP10, Kang-al:POPL17, 
Jeffrey-Riely:LICS16, PichonPharabod-Sewell:POPL16, 
Chakraborty-Vafeiadis:POPL19, Paviotti-al:ESOP20}.
Основная сложностью в данном направлении работ 
является предоставление формальных доказательств того, 
что эти продвинутые и сложные модели удовлетворяют 
всем предъявляемым требованиям. 

На сегодняшний день наиболее полное решение 
проблемы в данном классе моделей предоставляет 
так называемая ``обещающая'' семантика 
(\Promising semantics)~\cite{Kang-al:POPL17, Lee-al:PLDI20}. 
Было доказано, что эта модель допускает 
оптимальные схемы компиляции~\cite{Podkopaev-al:POPL19}, 
разрешает применение большинства локальных и глобальных 
трансформаций (за исключением слияние потоков), 
и в тоже время предоставляет 
свойство внешней свободы от гонок и другие гарантии. 

\subsection{Вспомогательная классификация}
\label{sec:analysis:other}

Мы также идентифицируем альтернативное разделение моделей на группы, 
на основе того, обладают ли они конкретным свойством, 
в частности, когерентностью и возгорающейся семантикой. 
Мы демонстрируем, как наличие этих свойств сказывается 
на оптимальности схемы компиляции и корректности некоторых трансформаций. 

\subsubsection{Модели с когерентностью}
\label{sec:analysis:coh}

Когерентность (также именуемая последовательной согласованностью 
по каждой локации \cref{sec:background:coh})
имеет неожиданный эффект на корректность удаления общих подвыражений (\CSE), 
который был впервые замечен в контексте ранней версии модели памяти \Java~\cite{Pugh:JAVA99}.
Чтобы увидеть проблемы, рассмотрим программу ниже (слева) 
и её версию после применения трансформации \CSE (справа).
Заметим, что оптимизация заменила второе обращение 
к переменной \texttt{x} чтением из регистра. 

\begin{minipage}{0.45\linewidth}
\begin{equation*}
\small
\inarrII{
  \readInst{}{r_1}{x}      \\
  \readInst{}{r_2}{y}      \\
  \readInst{}{r_3}{x}      \\
}{
  \writeInst{}{y}{1}       \\
}
\label{ex:coh-rr}
\end{equation*}
\end{minipage}\hfill%
\begin{minipage}{0.05\linewidth}
\Large~\\ $\leadsto$
\end{minipage}\hfill%
\begin{minipage}{0.45\linewidth}
\begin{equation*}
\small
\inarrII{
  \readInst{}{r_1}{x}      \\
  \readInst{}{r_2}{y}      \\
  \assignInst{r_3}{r_1}    \\
}{
  \writeInst{}{y}{1}       \\
}
\label{ex:coh-rr}
\end{equation*}
\end{minipage}

Предположим, что переменные \texttt{x} and \texttt{y} 
на самом деле указывают на одну и ту же ячейку памяти.  
При таком предположении можно сделать вывод, что 
сценарий выполнения с результатом ${[r_1=0, r_2=1, r_3=0]}$
должен быть запрещен моделью памяти, гаратирующей когерентность. 
В самом деле, когерентная модель памяти для программы, 
содержащей обращения только к одной локации в памяти, 
допускает только последовательно согласованные сценарии исполнения.
Результат ${[r_1=0, r_2=1, r_3=0]}$ не может быть получен
как последовательное чередование инструкций потоков, 
и значит он не является последовательно согласованным и должен быть запрещен.
Тем не менее, данный результат допустим для 
оптимизированной версии программы. 

Заметим, что несмотря на вышесказанное, компилятор 
все равно может применить оптимизацию \CSE к программе выше, 
но только если он сможет вывести, что переменные \texttt{x} и \texttt{y} 
указывают на разные локации в памяти. 
Это информация может быть получена при помощи 
анализа псевдонимов (alias analysis)~\cite{Diwan-al:PLDI1998}.
По сути, в этом случае \CSE может быть сведен к 
комбинации других трансформаций --- переупорядочиванию и элиминации инструкций. 

Таким образом, в общем случае свойство когерентность
несовместимо с удалением общих подвыражений. 
Что касается оптимальности схем компиляции, 
то здесь когерентность не накладывает каких-то 
дополнительных ограничений, 
так как модели памяти процессоров и так 
гарантируют соблюдение когерентности%
~\cite{Alglave-al:TOPLAS14, Sarkar-al:PLDI11, Sewell-al:CACM10, Lahav-al:PLDI17}. 

\subsubsection{Модели с возгорающейся семантикой}
\label{sec:analysis:ub}

Возгорающаяся семантика, которая присваивает 
неопределенное поведение программам, содержащим 
гонки на неатомарных обращениях, также влияет 
на корректность трансформаций. 
Как было упомянуто ранее, наличие подобного 
неопределенного поведения позволяет использовать
оптимальные схемы компиляции для неатомарных обращений
и влечет корректность широкого класса трансформаций, 
корректных для случая однопоточных программ. 
Но помимо этого, возгорающаяся семантика 
имеет интересное взаимодействие с трансформацией
введения спекулятивного чтения. 

Рассмотрим следующий пример:

\begin{minipage}{0.43\linewidth}
\begin{equation*}
\small
\inarrII{
  \readInst{}{r}{x}      \\
  \kw{if} {(r)} ~\{      \\
  \quad\readInst{}{s}{y} \\
  \}

}{
  \writeInst{}{y}{1}       \\
}
\label{ex:sliA}
\end{equation*}
\end{minipage}\hfill%
\begin{minipage}{0.09\linewidth}
\Large~\\ $\leadsto$
\end{minipage}\hfill%
\begin{minipage}{0.43\linewidth}
\begin{equation*}
\inarrII{
  \readInst{}{r_1}{x}      \\
  \readInst{}{t}{y}        \\
  \kw{if} {(r)} ~\{        \\
  \quad\assignInst{s}{t}   \\
  \}

}{
  \writeInst{}{y}{1}       \\
}
\label{ex:sliB}
\end{equation*}
\end{minipage}
 
В \cref{sec:background:trans} мы упоминали, 
что спекулятивное введение чтения может быть 
использовано в комбинации с элиминацией 
типа чтение/чтение, чтобы вынести инструкцию чтения
из одной из веток условного оператора. 
В частности, в примере выше, 
спекулятивное введения чтения может добавить 
инструкцию $\readInst{}{t}{y}$ перед условным оператором $\kw{if}$, 
а затем элиминация типа чтение/чтение может заменить 
второе чтение присваиванием значения из регистра. 

Тонкий момент заключается в том, что хотя 
программа слева не содержит гонок в модели 
последовательной согласованности, 
прграмма справа имеет гонку между 
чтением и записью в переменную \texttt{y}.
Исходя из этого, в предположении что все 
обращения в программе выше являются неатомарными, 
можно заключить, что возгорающаяся семантика 
должна рассматривать правую программу как 
имеющую неопределенное поведение. 
Другими словами, для программы справа 
допустим любой сценарий исполнения, 
в то время как для программы слева 
допустим только сценарий с результатом ${[r=0]}$.
Однако условие корректности трансформации требует, 
чтобы множество допустимых сценариев исполнения 
модифицированной программы было подмножеством 
сценариев поведения оригинальной программы. 
Можно видеть, что в этом примере условие корректности нарушается. 

Говоря простыми словами, спекулятивное введение чтения 
в общем случае некоректно в моделях с возгорающейся семантикой,
так как оно может привнести гонки в программы, 
которые не содержали гонок. 
Так как возгорающаяся семантика чувствительна 
к наличию или отсутствию гонок в программе, 
она не совместима с этой трансформацией. 

Заметим, что эту проблему нельзя обойти, 
запретив спекулятивное введение только неатомарных чтений, 
и разрешив вводить атомарные чтения. 
В самом деле, спекулятивно добавленное атомарное чтение
все ещё может находиться в состоянии гонки с 
каким-то неатомарным обращением, расположенным 
в другом месте программы. 
