\section{Анализ}
\label{sec:analysis}

% We partitioned all models into six primary classes: 
% sequentially consistent models, models with total or partial order on stores, 
% program order preserving models, syntactic dependency preserving models, 
% semantic dependency preserving models, and model with out of thin-air values.

В этой главе мы обсуждаем введеные класы моделей памяти.
На основе данных из таблицы 
мы выводим взаимосвязи между оптимальностью схемы компиляции,
корректностью трансформаций и предоставляемыми гарантиями. 
В частности, мы демонстрируем как поддержка 
некоторых гарантий конфликтует с некоторыми трансформациями 
и как она влияет на оптимальность схемы компиляции. 

Мы начинаем с рассмотрения класса 
последовательно согласованных моделей~\cref{sec:analysis:seqcst}.
Затем мы переходим к моделям с линейным или 
частичным порядком на записях~\cref{sec:analysis:tso}.
После этого, мы рассматриваем класс наиболее слабых моделей 
допускающих значения из воздуха~\cref{sec:analysis:oota}.
Далее мы переходим к обсуждению различных подходов 
к решению проблемы значений из воздуха и рассмариваем модели, 
сохраняющие программный порядок~\cref{sec:analysis:porf},
синтаксические зависимости~\cref{sec:analysis:deprf} и
семантические зависимости~\cref{sec:analysis:sdeprf}.
 
В \cref{sec:analysis:other} мы отдельно обсуждаем некоторые 
конкретные свойства моделей, в частности, когерентность и возгорающуюся семантику. 
Факт наличия или отсутствия этих свойств ортогонален
разбиению на вышеупомянутые классы. 
Тем не менее наличие этих свойств у модели также влияет 
на корректность определенных трансформаций.

\subsection{Последовательная Согласованность}
\label{sec:analysis:seqcst}

Модель последовательной согласованности (\SC)
является наиболее интуитивной моделью конкурентности.
В рамках этой модели состояние памяти может быть 
представлено как просто отображение из 
адресов переменных в хранящиеся значения. 
Тогда каждый допустимый сценарий поведения программы 
может быть получен в результате поочередного последовательного
исполнения инструкций потоков. 

Многие распростаненные трансформации оказываются 
некорректными в модели \SC, включая 
все типы переупорядочивания инструкций, 
а также удаление общих подвыражений~\cite{Marino-al:PLDI11, Sevcik-Aspinall:ECOOP08}.
Тот факт что переупорядочивание инструкций запрещено 
делает эту модель очень дорогостоящей при реализации
на современных процессорах, так как даже 
относительно строгая модель памяти \Intel
допускает переупорядочивания типа запись/чтение. 
Таким образом, чтобы гарантировать последовательную согласованность, 
компилятор вынужден вставлять в код тяжеловесные 
барьеры памяти между инструкциями записи и чтения,
что делает схему компиляции далеко не оптимальной. 

Однако в терминах предоставляемых программисту гарантий 
модель \SC является весьма привлекательной. 
В частности, тривиальным образом гарантируется свойства \DRF и когерентности, 
так как модель присваивает программе только 
последовательно согласованные сценарии поведения. 

Концептуальная простота и привлекательность модели \SC 
вдохновила многих исследователей на попытки 
адаптации этой модели и смягчения накладываемых 
штрафов на время исполнения программы. 
Общей идеей данных работ была попытка 
отделения локальных (доступных только одному потоку) 
и разделяемых переменных.
Обращения к локальным переменным могут быть скомпилированы 
без добавления барьеров памяти, также к ним 
применим широкий спектр оптимизация корректных 
для случая однопоточных программ. 
Чтобы безопасным образом классифицировать 
локальные и разлеляемы переменные исследователи 
использовали системы типов~\cite{Vollmer-al:PPoPP17},
статический~\cite{Singh-al:ISCA12} или динамический анализ~\cite{Liu-al:PLDI19}, 
поддержку на аппаратном уровне~\cite{Singh-al:ISCA12, Marino-al:PLDI10}, 
или различные комбинации вышеупомянутых методов.  

Несмотря на эти усилия, модель \SC все равно имеет существенные накладные расходы. 
Например, при компиляции на процессоры семейства \ARMv{8}
замедление времени работы программ может достигать 70\%~\cite{Liu-al:PLDI19} 
(\see подробности в \cref{sec:catalog:sc}).
Более того, хотя вышеупомянутые техники обычно уменьшают 
накладные расходы на локальные обращения 
(которые, зачастую, чаще встречаются в программах),
они оказывают меньшее влияние на специфичные приложения, 
которые активно использую конкурентность, 
например, такие как неблокирующие структуры данных.
Наконец, требуется значительное количество усилий 
и технической работы, чтобы модифицировать 
современные компиляторы для поддержки модели \SC~\cite{Marino-al:PLDI11, Liu-al:PLDI19}.

\subsection{Линейный и частичный порядок на записях}
\label{sec:analysis:tso}

Следующий рассматриваемый класс моделей был вдохновлен моделями с 
\emph{линейным порядком на записях} (\emph{total store order}, \TSO)
и \emph{частичным порядком на записях} (\emph{partial store order}, \PSO)~\cite{Sparc:94}.
Модели \TSO и \PSO являются моделями семейств процессоров \Intel~\cite{Sewell-al:CACM10} 
и \SPARC~\cite{Sparc:94} соответственно. 
В этих моделям потоки оснащены \emph{буферами записей}.
Все операции записи сперва попадают в эти буферы, а уже 
затем переносятся в основную память. 

Для моделей этого класса схема компиляции под архитектуру \Intel 
является оптимальной, так как \Intel предоставляет модель \TSO.  
Однако при компиляции под архитектуры с более слабой моделью памяти, 
например~\POWER, необходимо использовать практический такое же 
количество барьеров, как и при компиляции из модели~\SC~\cite{Lustig-al:AISCA15}.

Модели этого класса допускают большее количество трансформаций кода чем \SC.
Использование буферов записи позволяет выполнять переупорядочивание 
типа запись/чтение в случае~\TSO, и также 
переупорядочивание типа запись/запись в случае~\PSO.

Хотя модели \TSO и \PSO слабее модели \SC, 
тем не менее они все ещё предоставляют довольно сильные гарантии, 
в частности, свойсва \DRF и когерентности.    

Таким образом, модели этого класса не имеют 
значительных преимуществ перед моделью \SC, 
и при этом влекут соизмеримые накладные расходы 
при компиляции под архитектуры c более слабой моделью памяти чем у \Intel. 
Следовательно, выбор этих моделей в качестве моделей для 
языка программирования оправдан только если предполагается 
поддержка компиляции только под процессоры архитектуры \Intel. 

\subsection{Значения из воздуха}
\label{sec:analysis:oota}

Далле мы переместимся на другой конец спектра моделей памяти
и рассмотрим класс, в который входят наиболее слабые модели
из рассматриваемых нами. 
Эти модели предоставляют оптимальные схемы компиляции и 
допускают практический любые разумные трансформации программ, 
но достигают этого ценой введения значений из воздуха 
(\cref{sec:background:oota}).

Рассмотрим вновь пример программы буфферизации чтения:

\begin{minipage}{0.43\linewidth}
\begin{equation*}
\small
\inarrII{
  \readInst{}{r_1}{x}     \\
  \writeInst{}{y}{1}      \\
}{
  \readInst{}{r_2}{y}     \\
  \writeInst{}{x}{r_2}    \\
}
\tag{LB}\label{ex:lbA}
\end{equation*}
\end{minipage}\hfill%
\begin{minipage}{0.09\linewidth}
\Large~\\ $\leadsto$
\end{minipage}\hfill%
\begin{minipage}{0.43\linewidth}
\begin{equation*}
\inarrII{
  \writeInst{}{y}{1}      \\
  \readInst{}{r_1}{x}     \\
}{
  \readInst{}{r_2}{y}     \\
  \writeInst{}{x}{r_2}    \\
}
\tag{LBtr}\label{ex:lbB}
\end{equation*}
\end{minipage}

Версия программы справа \ref{ex:lbB} может быть 
получена из программы слева \ref{ex:lbA} 
путем применения переупорядочивания инструкций типа чтение/запись. 
Результат ${[r_1=1, r_2=1]}$ допустим для программы \ref{ex:lbB}.
Тогда модель памяти, в которой переупорядочивание типа чтение/запись
является корректной трансформацией, также должна 
допускать этот результат для программы \ref{ex:lbA}.
Как было продемонстрировано в \cref{sec:background:oota}, 
для того чтобы получить такой результат, 
необходимо прибегнуть к спекулятивному исполнению. 

Мы также обсуждали, что не ограниченное 
спекулятивное исполнение может привести к появлению 
так называемых значений из воздуха, 
которые нарушают фундаментальные гарантии 
о поведении программ~%
\cite{Boehm-Demsky:MSPC14, Batty-al:ESOP15}, 
в частности, гарантии типобезопасности (type-safety)
и композициональности.  
Также не выполняется и гарантия внешней свободы от гонок (\eDRF).
Чтобы убедиться в этом, рассмотрим ещё один пример:

\begin{equation*}
\inarrII{
  \readInst{}{r_1}{x}      \\
  \kw{if} {(r_1)} ~\{      \\
  \quad\writeInst{}{y}{1}  \\
  \}
}{
  \readInst{}{r_2}{x}      \\
  \kw{if} {(r_2)} ~\{      \\
  \quad\writeInst{}{x}{1}  \\
  \}
}
\tag{LB+ctrl}\label{ex:lb+ctrl}
\end{equation*}

Для модель памяти, допускающей значения из воздуха, 
результат ${[r_1=1, r_2=1]}$ также является допустимым
(обоснование этого результата такое же как и для 
примера \ref{ex:lb+data} из \cref{sec:background:oota}).
Однако этот результат не только совершенно неинтуитивен, 
но и противоречит гарантии внешней свободы от гонок. 
Действительно, в модели \SC единственный допустимый 
сценарий поведения этой программы ведет к результату $[r_1=0, r_2=0]$ 
и не содержит никаких гонок, следовательно 
в модели, предоставляющей гарантию \eDRF, 
эта программа также должа иметь только этот единственный 
сценарий поведения. 

Контр-интуитивное поведение моделей 
допускающих значения из воздуха, 
а также тот факт что они нарушают множество 
важных гарантий о поведении программ, 
привело к консенсусу в исследовательском сообществе о том, 
что эти модели не подходят на роль моделей памяти 
для языков программирования~\cite{Boehm-Demsky:MSPC14, Batty-al:ESOP15}.  
Множество усилий было приложено для того, 
чтобы запретить проблематичные значения из воздуха, 
но в то же время сохранить оптимальность схем 
компиляции и корректность как можно большего количества трансформаций. 
В оставшейся части этой главы мы опишем различные 
способы борьбы с проблемой значений из воздуха. 

\subsection{Сохранение программного порядка}
\label{sec:analysis:porf}

Наиболее простой способ запретить значения из воздуха 
был предложен в работе~\cite{Boehm-Demsky:MSPC14}.
Основная идея --- полностью запретить спекулятивное исполнение, 
что может быть достигнуто путем запрета переупорядочивания 
инструкций типа чтение/запись. 
Это решение позволяет не только восстановить 
свойство внешней свободы от гонок (\eDRF) 
и другие гарантии~\cite{Lahav-al:PLDI17}, 
но также ведет и к более простой модели. 
Абстрактная машина, реализующая данную модель, 
не нуждается в использовании спекулятивного исполнения
и может выполнять инструкции потоков согласно их
\emph{программному порядку}, \ie в том порядке, в котором они указаны. 
Память такой машины может быть организована 
как монотонно растущая история сообщений, 
где каждый поток имеет свой взгляд на 
фронт данной истории~\cite{Dolan-al:PLDI18, Doherty-al:PPoPP19}. 

Данный подход к решению проблемы значений из воздуха 
был формализован в работе~\cite{Lahav-al:PLDI17}.
Авторы работы показали, что многие трансформации над 
кодом программ, за исключением переупорядочивания 
инструкций типа чтение/запись, остаются корректными в рамках 
моделей данного класса (\see~\cref{table:cmp-cls})

Схема компиляции в процессоры семейства \Intel
является оптимальной, так как модель памяти данной 
архитектуры гарантирует сохранение порядка 
между чтениями и последующими записями. 
Однако более архитектуры с более слабыми моделями (\ARM, \POWER)
не гарантируют сохранения этого порядка, 
и таким образом требуют принятия дополнительных мер при компиляции кода. 
В~\cite{Boehm-Demsky:MSPC14} было предложено компилировать 
ослабленные ($\rlx$) чтения как обычные чтения, 
за которыми следует ложная инструкция условного прыжка 
(conditional jump), которая добавляет зависимость 
между чтением и последующими записями. 
Гарантируется, что процессоры семейств \ARM and \POWER 
сохранят такую зависимость, и, таким образом, 
сохранят и порядок между чтением и последующими записями. 
В работе~\cite{Ou-Demsky:OOPSLA18} изучались 
накладные расходы этой схемы компиляции, 
при её применении только к \textbf{ослабленным ($\rlx$) атомарным обращениям}.
При компиляции под процессоры семейства \ARMv{8} 
замедление времени работы составило 0\% в среднем и 6.3\% максимум 
на наборе тестов, реализующих различные конкурентные 
структуры данных, например, блокировки, стеки, очереди, 
деки, ассоциативные массивы, \etc
(подробности приведены в \ref{sec:catalog:porf}).
Заметим, что следует ожидать более существенного замедления
при применении данной схемы компиляции для 
сохранения порядка также между неатомарными обращениями. 

\subsection{Сохранение синтаксических зависимостей}
\label{sec:analysis:deprf}

Альтернативное простое решение проблемы значений из воздуха 
заключается в сохранении \emph{синтаксических зависимостей}~%
\cite{Boehm-Demsky:MSPC14, Alglave-al:ASPLOS18}.
В рамках этого подхода переупорядочивание типа чтение/запись 
разрешено, если переставляемые инструкции являются независимыми. 
Но переупорядочивание запрещено, если запись зависит 
от значения, прочитанного чтением, 
(в этом случае мы говорим что существует зависимость по данным, \emph{data dependency})
или если это значение было использовано при вычислении адреса записи 
(зависимость по адресу (\emph{address dependency}), 
или если путь исполнения программы, ведущей к записи, 
зависит от прочитанного значения 
(зависимость по управлению, (\emph{control dependency}).
Например, в программе \ref{ex:lb+data} 
сущесвтует зависимость по данным, так как 
инструкция $\writeInst{}{y}{r_1}$ записывает 
значение, прочитанное инструкцией $\readInst{}{x}{r_1}$. 

Заметим что эти зависимости вычисляются следую 
синтаксису программы (отсюда и название), 
в противоположность \emph{семантическим зависимостям}. 
Например, в модифицированной версии 
программы \ref{ex:lb+data}, показанной ниже, 
запись в переменную \texttt{y} в левом потоке все ещё 
имеет синтаксическую зависимость от предыдущего чтения. 

\begin{equation*}
\inarrII{
  \readInst{}{r_1}{x}           \\
  \writeInst{}{y}{1 + 0 * r_1}  \\
}{
  \readInst{}{r_2}{y}      \\
  \writeInst{}{x}{r_2}     \\
}
\tag{LB+fakedata}\label{ex:lb+fakedata}
\end{equation*}

В этом примере синтаксическая зависимость может быть удалена
при применении оптимизации распространения констант ---
подвыражение $1 + 0 * r_1$ может быть преобразовано в значение~$1$.
Однако если модель памяти гарантирует сохранение синтаксических зависимостей,
компилятору запрещено применять эту оптимизацию, 
так как после удаления зависимости ничто не мешает 
переставить запись до предшествующего чтения. 
Даже если сам компилятор не выполнит такое переупорядочивание, 
его может выполнить процессор во время исполнения 
скомпилированной программы. 

На этом примере можно видеть главный недостаток моделей, 
сохраняющих синтаксические зависимости --- 
различные оптимизации, сохраняющие трассы
(\eg распространение констант), некорректны в этих моделях. 
Распространение констант является одной из 
классических оптимизаций, и тот факт, 
что оно некорректно препятствует принятию 
моделей этого класса. 
Заметим, что модели архитекту процессоров 
используют схожий подход и тоже 
сохраняют синтаксические зависимости 
между обращениями к разделяемой памяти%
~\cite{Sarkar-al:PLDI11, Alglave-al:TOPLAS14, Pulte-al:POPL18}.
Однако в этом случае это не является проблемой, 
так как процессоры во время исполнения программы 
не выполняют такие сложные оптимизации, 
как распространение констант.

В работе~\cite{Ou-Demsky:OOPSLA18} изучалось 
замедление времени работы программ, накладываемое моделью памяти, 
сохраняющией синтаксические зависимости. 
Авторы модифицировали оптимизирующие проходы компилятора, 
чтобы они сохраняли зависиомости между 
\textbf{неатомарными и ослабленными ($\rlx$) атомарными} обращениями. 
Затем они измерили время работы программ из тестового набора \SPECCPU,
скомпилированных модифицированной версией компилятора \LLVM 
под процессор семейства \ARMv{8}, и сообщили 
об умеренном замедлении на 3.1\% в среднем и 17.6\% максимум
(подробности приведены в \ref{sec:catalog:deprf}). 

\subsection{Сохранение семантических зависимостей}
\label{sec:analysis:sdeprf}

Последний рассматриваемый нами подход к проблеме значений из воздуха 
заключается в построении понятия \emph{семантических зависимостей}, 
которые могли бы точно характеризовать какие пары чтения/записи
являеются независимыми, и отфильтровали бы ложные зависимости, 
как в примере \ref{ex:lb+fakedata}.
Практическая ценность данного подхода заключается в том, что 
он не требует модификаций существующих компиляторов 
и процессоров и не накладывает дополнительных 
расходов на время исполнения скомпилированных программ. 
Конечной целью является предоставление оптимальных схем компиляции, 
сохранение корректности большинства существующих трансформаций кода, 
и в то же время поддержка важных гарантий, 
таких как внешняя свобода от гонок (\eDRF).

Оказывается, что эта задача является весьма трудной 
и на сегодняшний день все ещё не существует консенсуса 
по способу её решения. 
Чтобы дать удовлетворительное определение семантических зависимостей 
исследователи вынуждены были обратиться к концептуально 
сложным моделям памяти~\cite{Jagadeesan-al:ESOP10, Kang-al:POPL17, 
Jeffrey-Riely:LICS16, PichonPharabod-Sewell:POPL16, 
Chakraborty-Vafeiadis:POPL19, Paviotti-al:ESOP20}.
Основная сложностью в данном направлении работ 
является предоставление формальных доказательств того, 
что эти продвинутые и сложные модели удовлетворяют 
всем предъявляемым требованиям. 

На сегодняшний день наиболее полное решение 
проблемы в данном классе моделей предоставляет 
так называемая ``обещающая'' семантика 
(\Promising semantics)~\cite{Kang-al:POPL17, Lee-al:PLDI20}. 
Было доказано, что эта модель допускает 
оптимальные схемы компиляции~\cite{Podkopaev-al:POPL19}, 
разрешает применение большинства локальных и глобальных 
трансформаций (за исключением слияние потоков), 
и в тоже время предоставляет 
свойство внешней свободы от гонок и другие гарантии. 

\subsection{Вспомогательная классификация}
\label{sec:analysis:other}

We also identified an alternative division of memory models into groups, 
which correspond to particular properties of a memory model, 
namely the coherence and the catch-fire semantics which treats racy programs 
as erroneous. We demonstrate how presence of these properties 
affects the compilation mappings and the soundness of some program transformations.

\subsubsection{Модели с когерентностью}
\label{sec:analysis:coh}

The coherence property (\ie \SC-per-location, \cref{sec:background:coh})
has a subtle effect on the common subexpression elimination optimization (\CSE),
which was was first observed in the context of an early version of the \Java 
memory model~\cite{Pugh:JAVA99}.
To see the problem, consider the program below
(on the left) and the transformed version 
of this program after application of \CSE (on the right).
Note that the optimization has replaced 
the second access to variable \texttt{x}
by the read from register. 

\begin{minipage}{0.45\linewidth}
\begin{equation*}
\small
\inarrII{
  \readInst{}{r_1}{x}      \\
  \readInst{}{r_2}{y}      \\
  \readInst{}{r_3}{x}      \\
}{
  \writeInst{}{y}{1}       \\
}
\label{ex:coh-rr}
\end{equation*}
\end{minipage}\hfill%
\begin{minipage}{0.05\linewidth}
\Large~\\ $\leadsto$
\end{minipage}\hfill%
\begin{minipage}{0.45\linewidth}
\begin{equation*}
\small
\inarrII{
  \readInst{}{r_1}{x}      \\
  \readInst{}{r_2}{y}      \\
  \assignInst{r_3}{r_1}    \\
}{
  \writeInst{}{y}{1}       \\
}
\label{ex:coh-rr}
\end{equation*}
\end{minipage}

Now assume that variables \texttt{x} and \texttt{y} 
point to the same memory location.
Under this assumption the outcome $[r_1=0, r_2=1, r_3=0]$
is forbidden for a memory model respecting coherence.
Indeed, the coherence guarantees sequential consistency per location, 
which means that for programs consisting of accesses 
to a single memory location 
(as the one above in the presence of aliasing) 
only the sequentially consistent outcomes are allowed.
The outcome $[r_1=0, r_2=1, r_3=0]$ cannot be obtained 
as the interleaving of instructions, and thus 
it should be forbidden.  
However, this outcome is allowed for 
the optimized version of the program. 

Note that the compiler still can apply \CSE to the program above, 
but only if it is able to prove that variables \texttt{x} and \texttt{y} 
point to disjoint memory locations, which can be achieved 
by the means of an alias analysis~\cite{Diwan-al:PLDI1998}.
In fact, in this case \CSE can be seen as a combination 
of instructiong reordering and elimination transformations.  

Therefore, the coherence property in general is not compatible 
with the common subexpression elimination.
As for compilation schemes, coherence does not require 
any changes here and thus does not impose any performance penalty.
It is because hardware models already guarantee coherence%
~\cite{Alglave-al:TOPLAS14, Sarkar-al:PLDI11, Sewell-al:CACM10, Lahav-al:PLDI17}. 

\subsubsection{Модели с возгорающейся семантикой}
\label{sec:analysis:ub}

A catch-fire semantics which treats racy non-atomic 
accesses as undefined behavior also affects  
soundness of program transformations. 
As we already briefly discussed, it enables 
the optimal compilation mapping for non-atomic accesses and 
makes sequentially valid transformations applicable 
to them, but its impact is not limited to this observation. 
A catch-fire semantics also has an interesting interplay
with the speculative load introduction.

Consider the following example:

\begin{minipage}{0.43\linewidth}
\begin{equation*}
\small
\inarrII{
  \readInst{}{r}{x}      \\
  \kw{if} {(r)} ~\{      \\
  \quad\readInst{}{s}{y} \\
  \}

}{
  \writeInst{}{y}{1}       \\
}
\label{ex:sliA}
\end{equation*}
\end{minipage}\hfill%
\begin{minipage}{0.09\linewidth}
\Large~\\ $\leadsto$
\end{minipage}\hfill%
\begin{minipage}{0.43\linewidth}
\begin{equation*}
\inarrII{
  \readInst{}{r_1}{x}      \\
  \readInst{}{t}{y}        \\
  \kw{if} {(r)} ~\{        \\
  \quad\assignInst{s}{t}   \\
  \}

}{
  \writeInst{}{y}{1}       \\
}
\label{ex:sliB}
\end{equation*}
\end{minipage}
 
As we mentioned in \cref{sec:background:trans}, 
the speculative load introduction can be used 
in combination with the load/load elimination 
to move a load instruction out of one branch of a conditional.
In more detail, giving the example above, 
the speculative load introduction can be applied
to add the load $\readInst{}{t}{y}$ before the $\kw{if}$ statement, 
and then the load/load elimination can be used 
to replace the second load with an assignment. 

The subtle point here is that while the 
left program is race free even under \SC, 
the right program is racy under \SC semantics,
because of the race between load and store to \texttt{y}.
This fact implies that if all accesses in the programs above 
are non-atomic, then a catch-fire semantics should 
treat the right program as having undefined behavior.
In other words, the right program allows any outcome,
while the left program allows only the outcome ${[r=0]}$.
Soundness of program transformation requires 
a set of outcomes of a transformed program 
to be a subset of outcomes of the original program. 
This condition is clearly violated in our example. 

Put simply, speculative load introduction in general
is unsound in catch-fire memory models, 
because it can bring data-races into otherwise 
race-free programs. Since catch-fire semantics
is sensitive to the presence of data-races 
it is incompatible with this transformation. 

Note that this problem cannot be mitigated 
by forbidding only non-atomic load introduction
and allowing atomic load introduction. 
Indeed, an introduced atomic load access still 
can race with some non-atomic load or store
located elsewhere in a program.  
