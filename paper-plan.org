#+TITLE: An Overview of Programming Language Memory Models
#+SUBTITLE: Plan of the research paper

* Abstract 
* Introduction
** Intro
*** importance of parallel/concurrent computing today
*** importance of formal semantics
** Memory model definition
** Sequential consistency (SC)
*** some example (program + its executions in SC)
*** advantage of SC --- simplicity
*** disadvantage of SC --- performance penalty
** Main tradeoff of WMMs: simplicity vs performance
** Types of WMMs
*** Hardware
*** Programming language
*** Different requirements and tradeoffs for HW/PL
** Programming language memory models (focus of this paper)
** Structure of the paper
* Requirements to Programming Language Memory Models
** Memory models under consideration
*** SC Memory Model 
**** "baseline" simple memory model
*** C/C++ Memory Model
**** should allow efficient compilation (zero-cost abstractions, don't pay for what you don't use, etc)
**** should allow agressive optimisations
**** can tolerate UB (Undefined Behaviour) in the semantics
*** Java Memory Model
**** should be as efficient as possible, yet
**** should be type and memory safe (no UB)
** Sound and efficient compilation scheme
*** examples
**** store buffering
***** simplified Dekker
***** discuss ~mfence~
***** C/C++ 
****** introduce ~rlx~ and ~sc~
****** explain how they are compiled
****** rewrite Dekker in C/C++
***** Java
****** introduce ~volatile~
****** explain how it is compiled
****** rewrite Dekker in Java
**** message passing
***** simplified spinlock
****** introduce CAS here?
***** discuss ~dmb~
***** C/C++
****** introduce ~rel~ and ~acq~
****** explain how they are compiled
****** explain the difference with ~sc~
*** discuss fences and dependencies (in general)
** Soundness of compiler optimisations
*** examples
**** an example of a transformation that is not sound in SC
**** an example of a transformation that is not sound in JMM
*** a list of transformations that we might want to support (?)
*** discuss UB and catch-fire semantics in C/C++
**** opportunities for compilation and optimisations
** Reasoning
*** DRF (non-expert-mode)
**** DRF-SC in Java
***** example
**** DRF-SC in C/C++
***** OOTA problem
****** example
***** external/internal DRF
*** being suitable for formal verification techiniques
**** model checking 
***** a couple of words about model checking of SC
****** naive approach --- just enumerate all executions
****** mention that problem is decidable and NP-complete 
******* for programs without unbounded recursion and with finite domains
***** mention that checking whether JMM allows specific execution is undecidable
***** challenging (if possible?) for C/C++ because of OOTA
** Summary
* Towards No-Thin-Air Memory Model
** Motivation 
** Promising
*** advantages
*** formal definition
**** operational semantics
***** explain timestamps and viewfronts
***** explain promises and certification
**** example
*** compilation
*** optimisations
*** reasoning
**** promise-free machine
**** DRF-RA
** Weakestmo
*** advantages
**** declarative
**** mention support for SC accesses
*** introduce event structures
*** formal definition
**** example
*** compilation
*** optimisations
*** reasoning
**** DRF-RLX
**** discuss model checking (not yet published) (?)
** Relaxed Modular Dependencies
*** advantages
**** mention that semantics is denotational
*** formal definition
**** example
*** compilation
*** optimisation
*** reasoning
**** discuss challenges for model checking
* Other Models
** JS/WASM Memory Model
*** introduce ~SharedArrayBuffer~
*** discuss mixed-size accesses
*** formal definition
**** examples (?)
*** compilation
*** optimisations

** OCaml Memory Model
*** intro (Multicore OCaml)
*** formal definition
**** axiomatic and operational version
*** compilation
*** optimisation
*** reasoning
**** local DRF
* Comparison
** Summary table
*** style: execution graphs, event structures, abstract machine
*** efficient compilation
*** compiler optimisations
*** DRF
*** UB
*** no OOTA
*** suitable for model checking
*** subjective complexity
** Summary table with compilation mappings (?)
** Summary table with supported optimisations (?)
** Summary table with performance overhead (?)
* Discussion and Open Problems
