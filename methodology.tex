\section{Methodology}

The purpose of our study is to compare weak memory models for programming languages.
In particular, with respect to each model we want to answer the following questions.

\begin{itemize}
  
  \item Can the memory model be efficiently implemented on modern hardware? 
    In other words, is the compilation scheme for a model sound and efficient?
    If the compilation scheme is not optimal, then how large is induced performance overhead?

  \item What compiler optimizations are correct in the model? What are not? 
    How large is performance impact for the generated code in case when 
    some optimizations are disabled due to unsoundness.

  \item What is the subjective complexity of the model?
    How easy it is to reason about the behavior of the model for non-experts?
    Is the model suitable for formal verification?
  
\end{itemize}

For our research we have chosen a number of memory models 
that we previously published in form of research papers 
in peer-reviewed journals or conference proceedings. 
Below we explain the motivation behind our choice of each particular memory model.  

%% Class of memory models (think how to introduce that)

%% We consider only "\CPP style" MMs

We included \SC~\cite{Lamport:TC79}
as a ``baseline'' memory model. 
It is simple, does not permit any counter-intuitive behaviors,
and has clear formal specification. 

We consider \Java memory model~(\JMM)~\cite{Manson-al:POPL05}
and \CPP memory model~(\CMM)~\cite{Boehm-Adve:PLDI08, Batty-al:POPL11}
because of their significance and impact on software engineering industry.

Next, we consider a number of proposed memory models 
that aim to repair \CPP model, namely 
\RCMM~\cite{Lahav-al:PLDI17}, 
\Promising~\cite{Kang-al:POPL17, Lee-el:PLDI20}, 
\Weakest~\cite{Chakraborty-Vafeiadis:POPL19}, 
\MRD~\cite{Paviotti-el:ESOP20}.

%% TODO: explain why we excluded~\cite{Jeffrey-Riely:LICS16, PichonPharabod-Sewell:POPL16}.
%% Jeffrey-Riely:LICS16 --> MRD
%% PichonPharabod --- mistakes, incomplete, (?)

Finally, we also included memory models of \OCaml~(\OCMM)~\cite{Dolan-al:PLDI18}
and \JS/\WASM~(\JSMM)~\cite{Watt-el:PLDI2020}.
These models are of some interest becuase 
they have some distinctive properties
that other models currently lacking.

We have consciously excluded several memory models from our review
for the following reasons.
We do not consider \OpenCL~\cite{Batty-el:POPL16} model 
because it inherets from the \CPP model.
All of the distinguished features of \OpenCL model comparing to \CPP
correspond to heteregeneous programming 
(\ie programming on a system where multiple CPU, GPU and FPGA processors can coexist),
which is beyond the scope of this paper. 
We also do not consider model proposed for \LLVM~\cite{Chakraborty-Vafeiadis:CGO17}
because it is based on the \Weakest~\cite{Chakraborty-Vafeiadis:POPL19} 
model which we do consider. 

\app{Mentioned that there are PL MMs, which have different to Java/C++ style of
  atomic interface, \emph{i.e.} \cite{Crary-Sullivan:POPL15}.
}
